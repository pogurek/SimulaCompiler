 Module MNTR("RTS 105");
 begin sysinsert COMN,SYSR,KNWN,UTIL,STRG,CENT,FIL,LIBR,SMST,SML;

       -----------------------------------------------------------------------
       ---                                                                 ---
       ---  COPYRIGHT 1985 by                                              ---
       ---  Simula a.s.                                                    ---
       ---  Postboks 335, Blindern                                         ---
       ---  N-0314 Oslo 3, Norway                                          ---
       ---                                                                 ---
       ---                                                                 ---
       ---                                                                 ---
       ---                 P O R T A B L E     S I M U L A                 ---
       ---                                                                 ---
       ---                  R U N T I M E     S Y S T E M                  ---
       ---                                                                 ---
       ---                                                                 ---
       ---                                                                 ---
       ---                                                                 ---
       ---   E r r o r    a n d    E x c e p t i o n    H a n d l i n g    ---
       ---                                                                 ---
       ---          B e g i n    a n d    E n d    P r o g r a m           ---
       ---                                                                 ---
       ---                                                                 ---
       ---                                                                 ---
       ---                                                                 ---
       --- The following abbreviations is used:                            ---
       ---                                                                 ---
       ---  AI - Active Instance                                           ---
       ---  AP - Active program Point (Active Point)                       ---
       ---  CE - Currently identified system Element (Current Element)     ---
       ---  CI - Currently identified Instance (Current Instance)          ---
       ---  OP - Observer Position                                         ---
       ---                                                                 ---
       --- The relation between CE and CI is as follows:                   ---
       --- CE is either an instance or an attribute of an instance.        ---
       --- CI is defined relative to CE. When CE is an instance, CI=CE.    ---
       --- When CE is an attribute of an instance, CI is the instance      ---
       --- of which CE is an attribute.                                    ---
       --- Both CE and CI are represented by the variable 'CE'             ---
       ---                                                                 ---
       ---                                                                 ---
       -----------------------------------------------------------------------
%title ***  M N E M O N I C S    a n d    R E C O R D S  ***
Define max_break = 60;          -- Max number of stmnt breaks

Define C_ALG=1,C_CS=2,C_DA=3,C_DL=4,C_DV=5,C_DDE=6,C_DEM=7,C_DOC=8,C_DOP=9,
       C_DSB=10,C_DTE=11,C_ID=12,C_LOE=13,C_LOS=14,C_LSF=15,C_LOF=16,C_MTAI=17,
       C_MTPI=18,C_MTDE=19,C_MTO=20,C_MTTE=21,C_OAC=22,C_OCF=23,C_OFE=24,
       C_OIG=25,C_OGC=26,C_OSE=27,C_OS=28,C_OSQ=29,C_OSN=30,C_OTG=31,
       C_RS=32,C_TE=33,C_STR=34,C_SLG=35,C_SSS=36,C_SSM=37,C_SLM=38 ;
Define C_max=38;      -- Number of commands defined;

Define EK_MAX = 9,    -- Element Kind Codes
       EK_NO  = 0,    -- Element is an instance
       EK_BLK = 1,    -- Element is a block attribute
       EK_VAL = 2,    -- Element is a value attribute (execpt array)
       EK_CLA = 3,    -- Element is a class (local)
       EK_PRO = 4,    -- Element is a procedure (local or parameter)
       EK_LAB = 5,    -- Element is a label (local or parameter)
       EK_SWT = 6,    -- Element is a switch (parameter)
       EK_ARR = 7,    -- Element is an array (not indexed)
       EK_IDX = 8,    -- Element is an array during indexing
       EK_ARV = 9;    -- Element is an indexed array element

--  Set Help Literals  --
Define H_CMND=1,H_VAR=2,H_PROG=3,H_BRK=4,H_FNAM=5,
       H_SML=6,H_GC=7,H_FIL=8,H_COND=9;
Define H_max=9;

Define EXC_UNS = 0;              -- Unspecified error condition
Define EXC_BRK = 10;             -- Breakpoint trap
Define EXC_ITR = 11;             -- User interrupt
Define EXC_TIM = 12;             -- Time limit exceeded
Define EXC_IMP = 13;             -- Continuation impossible
Define EXC_SST = 14;             -- Start of statement

Record PROGPNT;  INFO "TYPE";
begin label paddr;                 -- program Point,s address
      integer count;               -- event-count;
end;

Record ELEMENT;  INFO "TYPE";
begin ref(instance) ins;           -- The instance containing this element
      integer elt_kind;            -- Element kind
      integer atr_type;            -- Attribute type
      integer plv;                 -- Current attribute's prefix level
      ref(atrvec) atr_vec;         -- Used when value attribute
      integer idx;                 -- Index in atrvec
      -- In use under interpretation of array indices:
      ref(entity) arr;             -- the array described by CE.atr_vec
      integer aind;                -- current absolute array element index
      integer nind;                -- number of indices applied
      integer ind(MAX_DIM);        -- the indicies applied
end;
%title ***  G L O B A L    V A R I A B L E S   ***
integer errstat;           -- Current error status code
ref(instance) OP;          -- Observer Position
ref(instance) AI;          -- User's active instance
infix(ELEMENT) CE;         -- Current system Element
infix(ELEMENT) UE;         -- Utility system Element

ref(instance) previns;     -- The previously operating instance
Boolean interactive;       -- True: if we are executing interactively
Boolean SMB_TRC;           -- True: trace mode
Boolean RT_ERR;            -- True: treating an RT-error
Boolean LSTMODE;           -- True: in listing mode (i.e. list source lines)
Boolean SYSMODE;           -- True: in system mode (i.e. display system info)

integer er_msg;            --  Primary error message number.
integer er_msx;            --  Additional error message number.
range(0:MAX_ENO) er_no;
range(0:MAX_STS) er_sts;
range(0:MAX_TRM) er_trm;
ref(filent) er_fil;
infix(labqnt) erh;  --- After ERROR return label temp

Boolean MISS;              -- Missing SIMOB-info during ident-search
Boolean EXPR;              -- Attemption to evaluate name param expression
infix(string) inline;      -- Current input file's line
integer inpos;             -- Current input line's pos (0..inlng-1)
integer inlim;             -- First pos not within current item
infix(string) curid;       -- The current identifier

integer nbreaks;                  -- Number of stmnt breaks defined
infix(PROGPNT) stmnt(max_break);  -- Statement break table

integer CNT(EVT_max);       -- Event counts
integer FTRCNT(FTR_max);    -- File Event counts
integer SMLCNT(SML_max);    -- SIMULATION Event counts
integer GC_CNT(GC_max);     -- Garbage Collector Event counts

const infix(string) CMID(C_max) = (                       -- The command names;
      "ATTACH-LOGFILE <file-name>",                       -- C_ALG   =  1
      "CANCEL-STATEMENT <break-number>",                  -- C_CS    =  2
      "DISPLAY-ATTRIBUTE <variable>",                     -- C_DA    =  3
      "DISPLAY-LOCALS",                                   -- C_DL    =  4
      "DISPLAY-VISIBLES",                                 -- C_DV    =  5
      "DISPLAY-DYNAMIC-ENCLOSURES",                       -- C_DDE   =  6
      "DISPLAY-ERROR-MESSAGE",                            -- C_DEM   =  7
      "DISPLAY-OPERATING-CHAIN",                          -- C_DOC   =  8
      "DISPLAY-OBSERVER-POSITION",                        -- C_DOP   =  9
      "DISPLAY-SIMULATION-BLOCK",                         -- C_DSB   = 10
      "DISPLAY-TEXTUAL-ENCLOSURES",                       -- C_DTE   = 11
      "INPUT-DEVICE <file-name>",                         -- C_ID    = 12
      "LIST-OBSERVED-EVENTS",                             -- C_LOE   = 13
      "LIST-OBSERVED-STATEMENTS",                         -- C_LOS   = 14
      "LIST-SOURCE-FILE <file-name>",                     -- C_LSF   = 15
      "LIST-OPEN-FILES",                                  -- C_LOF   = 16
      "MOVE-TO-ACTIVE-INSTANCE",                          -- C_MTAI  = 17
      "MOVE-TO-PREVIOUS-INSTANCE",                        -- C_MTPI  = 18
      "MOVE-TO-DYNAMIC-ENCLOSURE",                        -- C_MTDE  = 19
      "MOVE-TO-OBJECT <variable>",                        -- C_MTO   = 20
      "MOVE-TO-TEXTUAL-ENCLOSURE",                        -- C_MTTE  = 21
      "OBSERVE-ARRAY-CREATION <condition>",               -- C_OAC   = 22
      "OBSERVE-CONTROL-FLOW <ON ! OFF>",                  -- C_OCF   = 23
      "OBSERVE-FILE-EVENTS  <event condition>*",          -- C_OFE   = 24
      "OBSERVE-INSTANCE-GENERATION <condition>",          -- C_OIG   = 25
      "OBSERVE-GARBAGE-COLLECTION <event condition>*",    -- C_OGC   = 26
      "OBSERVE-SIMULATION-EVENTS  <event condition>*",    -- C_OSE   = 27
      "OBSERVE-STATEMENT <program-point>",                -- C_OS    = 28
      "OBSERVE-SEQUENCING <condition>",                   -- C_OSQ   = 29
      "OBSERVE-SNAPSHOT <condition>",                     -- C_OSN   = 30
      "OBSERVE-TEXT-GENERATION <condition>",              -- C_OTG   = 31
      "RESUME-SIMULA",                                    -- C_RS    = 32
      "TERMINATE-EXECUTION",                              -- C_TE    = 33
      "SET-TRACE <ON ! OFF>",                             -- C_STR   = 34
      "SET-LOGFILE <ON ! OFF>",                           -- C_SLG   = 35
      "SET-SCREEN-SIZE <lines_per_screen>",               -- C_SSS   = 36
      "SET-SYSTEM-MODE <ON ! OFF>",                       -- C_SSM   = 37
      "SET-LISTING-MODE <ON ! OFF>"   );                  -- C_SLM   = 38
%title ***  E R R O R    H A N D L I N G  ***
 Visible body(pinierr) INIERR;
 begin label cont; er_no:=eno;
       if eno = ENO_SYS_1 then er_msg:=er_msx:= -1;
       else er_msg:=eno;
            if    (eno >= ENO_ITR_MIN) and (eno <= ENO_ITR_MAX)
            then  er_msx:=ENO_ITR_0
            elsif (eno >= ENO_FPT_MIN) and (eno <= ENO_FPT_MAX)
            then  er_msx:=ENO_FPT_0
            elsif (eno >= ENO_FNP_MIN) and (eno <= ENO_FNP_MAX)
            then  er_msx:=ENO_FNP_0
            else  er_msx:= -1 endif;
       endif;
       er_fil:=fil; er_sts:=status; status:=0; curins.lsc:=envir_OUTERMOST;
       if status <> 0 then status:=0; curins.lsc:=nowhere endif;
       case 0:MAX_ACT (act_lvl)
       when ACT_GC,ACT_INI,ACT_TRM: er_trm:=TRM_SYS; cont:=SYS_STMTS;
       when ACT_USR: er_trm:=TRM_ERR; cont:=USR_STMTS;
       when ACT_SMB: er_trm:=TRM_SYS; cont:=USR_STMTS; er_msx:=ENO_ITN_2;
       when ACT_ERR: er_trm:=TRM_SYS; cont:=TRM_STMTS;
       endcase;
       goto cont;
 end;


 Visible body(pexchdl) EXCHDL;
 begin curins.lsc:=addr; er_no:=code; er_msg:=er_no;
       case 0:MAX_EXC (code)
       when EXC_IMP:             -- Continuation Impossible: I.e. system error.
            er_no:=0; er_msg:= -1; cont:=nowhere;
       when EXC_TIM:             -- Time Limit Exceeded
            er_trm:=TRM_ERR;
            case 0:MAX_ACT (act_lvl)
            when ACT_GC,ACT_INI: cont:=SYS_STMTS;
            when ACT_TRM: cont:=addr;  -- If termination is going on, continue.
            otherwise cont:=TRM_STMTS endcase;
   --  when EXC_ITR: -- User Interrupt is NOT YET IMPLEMENTED !
       when EXC_BRK:
            case 0:MAX_ACT (act_lvl)
            when ACT_GC,ACT_INI,ACT_ERR:
                          er_msx:=ENO_ITN_1; er_trm:=TRM_SYS; cont:=SYS_STMTS;
            when ACT_USR: er_no:=0; er_msg:= -1;
                          bio.obs_evt:=EVT_BRK; cont:=SMB_STMTS;
            when ACT_SMB: er_msx:=ENO_ITN_2; er_trm:=TRM_SYS; cont:=USR_STMTS;
            when ACT_TRM: cont:=nowhere;                ---  Give in.
            endcase;
       otherwise
            er_msx:= -1;
            case 0:MAX_ACT (act_lvl)
            when ACT_GC,ACT_INI: er_trm:=TRM_SYS; cont:=SYS_STMTS;
            when ACT_USR: er_trm:=TRM_ERR; cont:=USR_STMTS;
            when ACT_SMB: er_msx:=ENO_ITN_2;
                          er_trm:=TRM_SYS; cont:=USR_STMTS;
            when ACT_ERR: er_trm:=TRM_SYS; cont:=TRM_STMTS;
            when ACT_TRM: cont:=nowhere;                ---  Give in.
            endcase;
    endcase;
 end;
%title ***  E V E N T    H A N D L E R  ***

Visible body(PSIMOB) SIMOB;
-- import integer code;
--        ref(entity) ent1,ent2;
begin Boolean run_time_error_occurred,dialogue;
      integer index;   -- current break index
      integer x;       -- current command index ;

      run_time_error_occurred:=false; dialogue:=false;
      previns:=none; -- Previously operating instance
      AI:=curins; -- Reactivation point of user program --
      repeat while AI.lsc=nowhere do AI:=AI.dl endrepeat;
      OP:=AI; RT_ERR:=false; pgleft:=pgsize;

      case 0:EVT_max (bio.obs_evt)
 when EVT_ITR:  PRT("*** ATTENTION INTERRUPT:")
                dialogue:=interactive;
 when EVT_BRK:  -- index := <this break's index>;
                index := -1;
                repeat index:=index+1 while index < max_break do
                if stmnt(index).paddr=curins.lsc then goto FBRK endif endrepeat;
                run_time_error_occurred:=true;
                PRT("*** UNRECOGNIZED STATEMENT BREAK:"); goto EBRK;
          FBRK: if stmnt(index).count > 0 then
                stmnt(index).count:=stmnt(index).count-1; goto USER1 endif;
                PRT("*** STATEMENT BREAK:");
          EBRK: dialogue:=interactive;
                if interactive then ED_AT_IN("*** ",OP)
                else DISPLAY_OPERATING_CHAIN endif;
 when EVT_ERR:  RT_ERR:=true;
                if bio.erh.sl <> none
                then if envir_GET_INTINFO(19) > 0
                     then ED_ERR(er_no,er_fil,er_msg,er_msx,er_sts);
                          if interactive then ED_AT_IN("*** ",OP)
                          else pgsize:=0; DISPLAY_OPERATING_CHAIN endif;
                          dialogue:=interactive;
                     else dialogue:=false endif;
                     if status<>0 then status:=0; dialogue:=false endif;
                else ED_ERR(er_no,er_fil,er_msg,er_msx,er_sts);
                     if interactive then ED_AT_IN("*** ",OP)
                     else pgsize:=0; DISPLAY_OPERATING_CHAIN endif;
                     run_time_error_occurred:=true; dialogue:=interactive;
                endif;
 when EVT_BPRG: PRT("Begin Portable SIMULA Execution.");
                PRT("S-PORT Release number 105"); bio.trc:=false;
                dialogue:=interactive;
 when EVT_EPRG: ED_OUT; ED_STR("End of Portable SIMULA Execution.");
                ED_STR(",  CPU Time used: "); bio.trc:=false;
                ED_LFIX(envir_GET_CPU_TIME-bio.ini_tim); ED_OUT;
                dialogue:=interactive;
 when EVT_BEG:
      if CNT(EVT_BEG) > 0 then CNT(EVT_BEG):=CNT(EVT_BEG)-1
      elsif CNT(EVT_BEG) = 0
      then previns:=DYN(curins);
           if previns=none then previns:=curins.sl endif;
           ED_LSC(previns);
           if curins.sort=S_ATT
           then ED_STR(" new ") else ED_STR(" begin ") endif;
           ED_ENT_IDT(curins); ED_OUT; dialogue:=interactive;
      endif;

 when EVT_END: ---  ref(instance) cont; --  Continue execution in this instance
      if CNT(EVT_END) > 0 then CNT(EVT_END):=CNT(EVT_END)-1
      elsif CNT(EVT_END) = 0
      then ED_LSC(curins); ED_STR(" end ");
           ED_ENT_IDT(curins); ED_OUT; dialogue:=interactive;
      endif;

 when EVT_GOTO: --- Par ent1=the instance executing goto
      if CNT(EVT_GOTO) > 0 then CNT(EVT_GOTO):=CNT(EVT_GOTO)-1
      elsif CNT(EVT_GOTO) = 0
      then ED_LSC(ent1); ED_ENT_IDT(ent1);
           ED_STR("  goto  "); ED_LSC(curins); ED_ENT_IDT(curins);
           previns:=ent1; ED_OUT; dialogue:=interactive;
      endif;

 when EVT_QPS: --- Par code, ent1=oldins, ent2=component
      if CNT(EVT_QPS) > 0 then CNT(EVT_QPS):=CNT(EVT_QPS)-1
      elsif CNT(EVT_QPS) = 0
      then ED_LSC(ent1); previns:=ent1;
           case 0:2 (code)
           when 0: ED_STR(" detach "); ED_ENT_IDT(ent2);
           when 1: ED_STR(" call ");   ED_ENT_IDT(curins);
           when 2: ED_STR(" resume "); ED_ENT_IDT(curins);
           endcase;
           ED_OUT; dialogue:=interactive;
      endif;

 when EVT_ARR: --- Par code=array-type, ent1=arrent
      if CNT(EVT_ARR) > 0 then CNT(EVT_ARR):=CNT(EVT_ARR)-1
      elsif CNT(EVT_ARR) = 0
      then ED_LSC(curins); ED_STR(" new "); ED_ARR(ent1);
           ED_OUT; dialogue:=interactive;
      endif;

 when EVT_TXT: --- Par ent1=new text entity
      if CNT(EVT_TXT) > 0 then CNT(EVT_TXT):=CNT(EVT_TXT)-1
      elsif CNT(EVT_TXT) = 0
      then ED_LSC(curins); ED_STR(" new text ");
 --        ED_TEXT(??????,trc_lvl >= 6);
           ED_OUT; dialogue:=interactive;
      endif;

 when EVT_SNAP:
      if CNT(EVT_SNAP) > 0 then CNT(EVT_SNAP):=CNT(EVT_SNAP)-1
      elsif CNT(EVT_SNAP) = 0
      then ED_LSC(curins); PRT("  snapshot  "); dialogue:=interactive endif;

 when EVT_FIL:
      if FTRCNT(code) > 0 then FTRCNT(code):=FTRCNT(code)-1
      elsif FTRCNT(code) = 0
      then FIL_EVENT(code,ent1); dialogue:=interactive endif;

 when EVT_SML:
      if SMLCNT(code) > 0 then SMLCNT(code):=SMLCNT(code)-1
      elsif SMLCNT(code) = 0
      then SML_EVENT(code,ent1); dialogue:=interactive endif;

 when EVT_GC:
      if code=GC_FIL then GC_EVENT(code,ent1); dialogue:=interactive;
      elsif GC_CNT(code) > 0 then GC_CNT(code):=GC_CNT(code)-1
      elsif GC_CNT(code) = 0
      then GC_EVENT(code,ent1); dialogue:=interactive endif;

 otherwise dialogue:=interactive endcase;
      bio.obs_evt:=0;

      repeat while dialogue
      do -- Check if the observer has pressed the attention key --
         -- while SIMOB was interpreting the previous command.  --
         if bio.obs_evt=EVT_ITR then --- ???????????
                                endif;

         inlim:=inpos:=inlng; errstat:=0; MISS:=false; pgleft:=pgsize;
         x:=command_no(prompt("CMND: ",H_CMND));

         case 0:C_max (x)
         when C_CS:   CANCEL_STATEMENT
         when C_DA:   DISPLAY_ATTRIBUTE
         when C_DL:   DISPLAY_LOCALS
         when C_DV:   DISPLAY_VISIBLES
         when C_DOC:  DISPLAY_OPERATING_CHAIN
         when C_DDE:  DISPLAY_DYNAMIC_ENCLOSURES
         when C_DEM:  DISPLAY_ERROR_MESSAGE
         when C_DOP:  ED_OP;
                      if LSTMODE then LIST_OBSERVER_POSITION endif;
         when C_DSB:  DISPLAY_SIMBLK
         when C_DTE:  DISPLAY_TEXTUAL_ENCLOSURES
         when C_ID:   INPUT_DEVICE
         when C_LOE:  LIST_OBSERVED_EVENTS
         when C_LOS:  LIST_OBSERVED_STATEMENTS
         when C_LSF:  LIST_SOURCE
         when C_LOF:  LIST_OPEN_FILES
         when C_MTAI: MOVE_TO_ACTIVE_INSTANCE
         when C_MTPI: MOVE_TO_PREVIOUS_INSTANCE
         when C_MTDE: MOVE_TO_DYNAMIC_ENCLOSURE
         when C_MTO:  MOVE_TO_OBJECT
         when C_MTTE: MOVE_TO_TEXTUAL_ENCLOSURE
         when C_OCF:  OBSERVE_CNT(0,incond)
         when C_OAC:  OBSERVE_CNT(EVT_ARR,incond)
         when C_OFE:  OBSERVE_FIL
         when C_OSE:  OBSERVE_SML
         when C_OGC:  OBSERVE_GC
         when C_OIG:  OBSERVE_CNT(EVT_BEG,incond)
         when C_OSQ:  OBSERVE_CNT(EVT_QPS,incond)
         when C_OSN:  OBSERVE_CNT(EVT_SNAP,incond)
         when C_OTG:  OBSERVE_CNT(EVT_TXT,incond)
         when C_OS:   OBSERVE_STATEMENT
         when C_RS:   goto USER2
         when C_TE:   SMB_TERM
         when C_ALG:  ATTACH_LOGFILE
         when C_STR:  SMB_TRC:=inonoff
         when C_SLG:  SET_LOGFILE(inonoff)
         when C_SSS:  prompt("Number: ",0); pgsize:=innumber
         when C_SSM:  SYSMODE:=inonoff
         when C_SLM:  LSTMODE:=inonoff
    otherwise FAILED("Unknown command -- Type ? for information");
         endcase;
         pgleft:=pgsize;
      endrepeat;
USER1:USER2: if run_time_error_occurred then SMB_TERM endif;
      bio.act_lvl:=ACT_USR;
end;


Routine SMB_TERM;
--  PURPOSE: perform an user requested termination of the user system.
begin bio.act_lvl:=ACT_USR; E_PROG(TRM_REQ,nostring) end;

Routine SML_EVENT; import integer code; ref(entity) ent;
begin ED_OUT; ED_STR("Time"); ED_REAL(smltim qua real); ED_STR(": ");
      case 0:SML_max (code)
      when SML_PASS: ED_STR("passivate ");
      when SML_CANC: ED_STR("cancel ");
      when SML_WAIT: ED_ENT_IDT(ent qua linkage.prd);
                     ED_STR(" into Wait-queue: ");
      when SML_HOLD: ED_STR("hold until time");                     goto R1;
      when SML_ACTI: ED_STR("activate ");                           goto T1;
      when SML_ACT1: PRT("activate none");                          goto E1;
      when SML_ACT2: ED_STR("activate terminated ");
      when SML_ACT3: ED_STR("activate scheduled ");
      when SML_RACT: ED_STR("reactivate ");                         goto T2;
      when SML_RAC1: PRT("reactivate none");                        goto E2;
      when SML_RAC2: ED_STR("reactivate terminated ");
      when SML_RAC3: PRT("reactivate before/after itself");         goto E3;
      when SML_RAC4: PRT("reactivate current=");                    goto T3;
      endcase;
      ED_ENT_IDT(ent); ED_OUT; goto E4;
T1:T2:T3: ED_ENT_IDT(ent); ED_STR(" at time ");
      R1: ED_REAL(ent qua process.rnk qua real); ED_OUT;
E1:E2:E3:E4:end;


Routine FIL_EVENT; import integer code; ref(filent) fil;
begin case 0:FTR_max (code)
      when FTR_OPEN: ED_STR(" open ");
      when FTR_CLOS: ED_STR(" close ");
      when FTR_INIM: ED_STR(" inimage ");
      when FTR_UTIM: ED_STR(" outimage ");
      when FTR_LOCA: ED_STR(" locate ");
      when FTR_ENDF: ED_STR(" endfile := true ");
      endcase;
      ED_STR(" on file: ");
      if    fil=bio.sysin  then PRT("sysin")
      elsif fil=bio.sysout then PRT("sysout")
      else  PRT(TXT_TO_STR(fil.nam)) endif;
end;


Routine GC_EVENT; import integer code; ref(entity) ent;
begin case 0:GC_max (code)
      when GC_BEG: ED_OUT; ED_LSC(curins); ED_STR(" ********* ");
                   PRT("Begin  Garbage  Collection.")
      when GC_EP1: PRT("End of Garbage Collection Pass 1");
      when GC_EP2: PRT("End of Garbage Collection Pass 2");
      when GC_END: ED_OUT; ED_LSC(curins); ED_STR(" ********* ");
                   PRT("End of Garbage  Collection.")
      when GC_PRC1,GC_PRC3,GC_UPD3: -- Follow update etc.
--         ED_STR(str);
--         if ent = none then ED_STR(" none"); ED_OUT;
--         else ED_ENT_IDT(ent);
--              if trc_gc >= 3 then DMP_ENT(ent) endif;
--              ED_OUT;
--         endif;
      when GC_FIL: --- Unclosed file found as Garbage ---
           ED_STR("The non-referencable open File ");
           ED_STR(TXT_TO_STR(ent qua filent.nam));
           ED_STR(" was found during Garbage Collection");
           PRT(" -- Closed by Simula Runtime System");
           CLOSE(ent);
      endcase;
end;
%title ***  I n v a r i a b l e  ***
Routine invariable; export Boolean all_attr;
-- Interprets an identification, either remote, indexed or simple. **;
-- The identification is interpreted as a sequence of simple       **;
-- identifications, where the simple identifications are seperated **;
-- by dots. When this Routine returns, the attribute which the     **;
-- identification identified is known to the run-time system.      **;
--                                                                 **;
--                                                                 **;
-- If an object or a text is identified together with all their    **;
-- attributes, then 'true' is returned.                            **;
--                                                                 **;
-- The identification is done relative to the observer position.   **;
begin character c; infix(string) id;
      Boolean found,scope_lim; ref(instance) ins;

      scope_lim:=false; all_attr:=false;
      CE.ins:=OP; CE.elt_kind:=EK_NO; -- set current to observer position;
      prompt("Variable: ",H_VAR);
IDN:  id:=inidentifier; if errstat > 0 then goto E1 endif;
      if scope_lim then found:=FIND_ATTR(CE.ins,id)
                   else found:=FIND_IDENT(CE.ins,id) endif;
      if not found then SMB_ERR(id," is not found"); goto E2 endif;
      --  Interpret any indices;
      if nextbyte='('
      then getbyte; INDX_INIT;
           if EXPR then EXPR:=false; FAILED("Array by name"); goto E3 endif;
           repeat if not moreinfo then goto L1 endif;
                  if number then INDX_NUMBER(innumber)
                  else INDX_IDENT(inidentifier) endif;
                  if errstat > 0 then goto E4 endif;
           L1:    c:=getbyte;
                  if c='@'
                  then prompt("Index: ",0);
                       if nextbyte = ')' then c:=')' else c:=',' endif;
                  endif;
           while c=',' do endrepeat;
           INDX_TERM; if errstat > 0 then goto E5 endif;
           if c <> ')' then FAILED("Missing  )") endif;
      endif;

      if nextbyte = '.'
      then getbyte; scope_lim:=true;
           if CE.atr_type=T_REF
           then ins:=EVAL_REF;
                if ins=none then SMB_ERR(curid," == none"); goto E6 endif;
                CE.ins:=ins; CE.elt_kind:=EK_NO;
                if nextbyte='*' then c:=getbyte else goto IDN endif;
           elsif CE.atr_type=T_TXT
           then c:=getbyte;
                if c <> '*' then SMB_ERR(curid," is a text"); goto E7 endif;
           else SMB_ERR(curid," is neither text nor reference"); goto E8 endif;
      endif;
      all_attr:= c='*';
      if moreinfo then FAILED("Syntax error") endif;
E1:E2:E3:E4:E5:E6:E7:E8: if MISS then
      PRT("** Warning **  Insufficient info for identifier search") endif;
end;
%title ***   A r r a y    I n d e x i n g   ***
Routine INDX_INIT; -- Initiate for indexing of array in CE
begin name() adr; EXPR:=false;
      if CE.elt_kind <> EK_ARR
      then SMB_ERR(curid," is not an array"); goto E1 endif;
      adr:=CE.ins+CE.atr_vec.atr(CE.idx).fld;
      if CE.atr_vec.atr(CE.idx).mode = M_NAME
      then -- adr is address of an infix(PARQNT)
           if var(adr qua name(infix(PARQNT))).sem
           then adr:=var(adr qua name(infix(PARQNT))).ent
                   + var(adr qua name(infix(PARQNT))).fld;
           else EXPR:=true; goto E2 endif;
      endif;
      CE.arr:=var(adr qua name(ref(entity)));
      CE.elt_kind:=EK_IDX;
E1:E2:end;


Routine INDX_TERM;   -- Terminate the interpretation of array indices.
begin if CE.elt_kind = EK_IDX then FAILED("Too few array indices")
      elsif CE.elt_kind <> EK_ARV then IERR("IT1") endif;
end;


Routine INDX_NUMBER;
import integer ind;         -- array index
-- Interpretation of an array index which is an integer literal.
-- Check that correct number of indices is not exceeded.  Check
-- index out of bounds. Update actual index 'aind'
begin ref(arent1) A1; ref(arent2) A2; integer aind,cind,dim,nbase;
      ref(arhead) head; infix(arrbnd) bnd;
      if CE.elt_kind <> EK_IDX then IERR("IN1") endif;
      aind:=CE.aind; cind:=CE.nind;
      CE.ind(cind):=ind; cind:=cind+1; CE.nind:=cind;
      case  0:MAX_SORT (CE.arr.sort)
      when S_ARENT1,S_ARREF1,S_ARTXT1:         -- Array is one-dimensional.
           A1:=CE.arr;
           if cind = 1
           then if    ind < A1.lb then FAILED("Array index < lower bound")
                elsif ind > A1.ub then FAILED("Array index > upper bound")
                else aind:=ind - A1.lb endif;
                CE.elt_kind:=EK_ARV;
           else FAILED("Too many indices") endif;
      when S_ARENT2,S_ARREF2,S_ARTXT2:         -- Array is two-dimensional.
           A2:=CE.arr;
           if cind = 1
           then if    ind < A2.lb_1 then FAILED("Array index < lower bound")
                elsif ind > A2.ub_1 then FAILED("Array index > upper bound")
                else aind:=ind+A2.neg_base endif;
           elsif cind = 2
           then if    ind < A2.lb_2 then FAILED("Array index < lower bound")
                elsif ind > A2.ub_2 then FAILED("Array index > upper bound")
                else aind:=ind*A2.dope+aind endif;
                CE.elt_kind:=EK_ARV;
           else FAILED("Too many indices") endif;
      when S_ARBODY:                           --  Array is multi-dimensional.
           head:=CE.arr qua arbody.head;
           if cind > head.ndim then FAILED("Too many indices")
           else bnd:=head.bound(cind-1);
                if    ind < bnd.lb then FAILED("Array index < lower bound")
                elsif ind > bnd.ub then FAILED("Array index > upper bound")
                endif;
                if cind = head.ndim
                then CE.elt_kind:=EK_ARV;
                     if errstat > 0 then goto E endif;
                     dim:=head.ndim-1; bnd:=head.bound(dim);
                     nbase:=bnd.neg_base; aind:=CE.ind(dim);
                     repeat while dim > 0
                     do dim:=dim - 1; bnd:=head.bound(dim);
                        aind:=aind * bnd.dope + CE.ind(dim);
                     endrepeat;
                     aind:=aind + nbase;
                endif
           endif;
      otherwise IERR("IN2") endcase;

      if errstat=0 then CE.aind:=aind endif;
E:end;


Routine INDX_IDENT;
import infix(string) ident;             -- identifier
-- Interpretation of an array index which is a single identifier.
-- Check that correct number of indices is not exceeded.  Search for
-- an integer attribute in the scope of the observer position which
-- is associated with 'ident'.  Check index out of bounds.  Store its
-- value as the next index in an indexed array expression.
begin integer x; Boolean found;
      UE:=CE; CE.ins:=OP; found:=FIND_IDENT(CE.ins,ident)
      if MISS then
      PRT("** Warning **  Insufficient info for identifier search") endif;
      if found
      then if CE.atr_type=T_INT    then x:=EVAL_INT
           elsif CE.atr_type=T_SIN then x:=EVAL_SINT
           else SMB_ERR(ident," is not of type integer"); CE:=UE; goto E1 endif;
           CE:=UE;
           if EXPR then FAILED("Can't evaluate name parameter"); EXPR:=false;
           else INDX_NUMBER(x) endif;
      endif;
E1:end;
%title ***  D i s p l a y    C u r r e n t    E l e m e n t  ***
Routine DISPL_CE; import Boolean star;
begin integer i; real r; long real lr; character c;
      Boolean b; ref() x; infix(txtqnt) t;

      case 0:EK_MAX (CE.elt_kind)
      when EK_BLK: --- ED_BLKID(CE.blk_vec.blk(CE.idx).pp);
                                                        goto E1;
      when EK_VAL: ED_IDT(CE.atr_vec.atr(CE.idx).ident);
      when EK_CLA: ED_IDT(CE.atr_vec.atr(CE.idx).ident);
                   ED_STR(": Class");  ---     T  E  M  P     ---
                   goto E2;
      when EK_PRO: ED_IDT(CE.atr_vec.atr(CE.idx).ident);
                   ED_STR(": Procedure");  ---     T  E  M  P     ---
                   goto E3;
      when EK_LAB: ED_IDT(CE.atr_vec.atr(CE.idx).ident);
                   ED_STR(": Label");  ---     T  E  M  P     ---
                   goto E4;
      when EK_SWT: ED_IDT(CE.atr_vec.atr(CE.idx).ident);
                   ED_STR(": Switch");  ---     T  E  M  P     ---
                   goto E5;
      when EK_ARR: ED_IDT(CE.atr_vec.atr(CE.idx).ident); ED_STR(": ");
                   INDX_INIT; CE.elt_kind:=EK_ARR;
                   if EXPR then EXPR:=false; ED_STR("array by name")
                   elsif CE.arr <> none then ED_ARR(CE.arr)
                   else ED_STR("uninitialized array") endif;   goto E6;
      when EK_ARV: ED_IDT(CE.atr_vec.atr(CE.idx).ident);
                   ED_CHAR('('); i:=0;
                   repeat ED_INT(CE.ind(i)); i:=i+1;
                   while i < CE.nind do ED_CHAR(',') endrepeat;
                   ED_CHAR(')');
      endcase;

      ED_STR(": ");
      case 0:MAX_TYPE (CE.atr_type)
      when T_INT: i:=EVAL_INT;    if not EXPR then ED_INT(i) endif;
      when T_SIN: i:=EVAL_SINT;   if not EXPR then ED_INT(i) endif;
      when T_REA: r:=EVAL_REAL;   if not EXPR then ED_REAL(r) endif;
      when T_LRL: lr:=EVAL_LREAL; if not EXPR then ED_LREAL(lr) endif;
      when T_CHA: c:=EVAL_CHAR;
                  if not EXPR then ED_STR("'"); ED_CHAR(c); ED_STR("'") endif;
      when T_BOO: b:=EVAL_BOOL;
                  if not EXPR then ED_STR(if b then "True" else "False") endif;
      when T_REF: x:=EVAL_REF;  if not EXPR then ED_ENT_IDT(x) endif;
      when T_TXT: t:=EVAL_TEXT; if not EXPR then ED_TEXT(t,not star) endif;
      otherwise   ED_STR("???")  endcase;
      if EXPR then EXPR:=false; ED_STR("expression") endif;
E1:E2:E3:E4:E5:E6:ED_OUT;
end;

Macro EVAL(6);
--- Par 1:Routine-name, 2:Quant-variant, 3:Result-type, 4-6:Array-entity-types
begin Routine %1; export %3 val;
      begin name() adr; EXPR:=false;
            if CE.atr_vec.atr(CE.idx).kind = K_ARR
            then -- CE describes an array: we want value of particular element.
                 -- The array reference has been put into arr
                 -- and indexing is done giving absolute element
                 -- index in aind (by INDX_INIT, ... , INDX_TERM).
                 if    CE.nind=1 then val:=CE.arr qua %4 .elt(CE.aind)
                 elsif CE.nind=2 then val:=CE.arr qua %5 .elt(CE.aind)
                                 else val:=CE.arr qua %6 .elt(CE.aind) endif;
            else -- CE describes a simple quantity
                 adr:=CE.ins+CE.atr_vec.atr(CE.idx).fld;
                 if CE.atr_vec.atr(CE.idx).mode = M_NAME
                 then -- adr is address of an infix(PARQNT)
                      if var(adr qua name(infix(PARQNT))).sem
                      then adr:=var(adr qua name(infix(PARQNT))).ent
                              + var(adr qua name(infix(PARQNT))).fld;
                      else EXPR:=true; goto E endif;
                 endif;
                 val:=var(adr qua name(infix(quant))). %2 ;
            endif;
      E:end;
endmacro;                    Routine dummy; begin end;  --- T E M P ---

EVAL(%EVAL_BOOL%,%boo%,%Boolean%,%boo_arr_1%,%boo_arr_2%,%boo_arr%);
EVAL(%EVAL_CHAR%,%cha%,%Character%,%cha_arr_1%,%cha_arr_2%,%cha_arr%);
EVAL(%EVAL_REAL%,%rea%,%real%,%rea_arr_1%,%rea_arr_2%,%rea_arr%);
EVAL(%EVAL_LREAL%,%lrl%,%long real%,%lrl_arr_1%,%lrl_arr_2%,%lrl_arr%);
EVAL(%EVAL_INT%,%int%,%integer%,%int_arr_1%,%int_arr_2%,%int_arr%);
EVAL(%EVAL_SINT%,%sin%,%short integer%,%sin_arr_1%,%sin_arr_2%,%sin_arr%);
EVAL(%EVAL_TEXT%,%txt%,%infix(txtqnt)%,%txt_arr_1%,%txt_arr_2%,%txt_arr%);


Routine EVAL_REF; export ref(entity) val;
begin name() adr; EXPR:=false;
      if CE.atr_vec.atr(CE.idx).kind = K_ARR
      then -- CE describes an array: we want value of particular element.
           -- The array reference has been put into arr
           -- and indexing is done giving absolute element
           -- index in aind (by INDX_INIT, ... , INDX_TERM).
           if    CE.nind=1 then val:=CE.arr qua ref_arr_1.elt(CE.aind)
           elsif CE.nind=2 then val:=CE.arr qua ref_arr_2.elt(CE.aind)
                           else val:=CE.arr qua ref_arr.elt(CE.aind) endif;
      else -- CE describes a simple quantity
           adr:=CE.ins+CE.atr_vec.atr(CE.idx).fld;
           if CE.atr_vec.atr(CE.idx).mode = M_NAME
           then if CE.ins.sort <> S_PRO
                then -- Special case:  PROCESS.NEXTEV
                     val:=NEXTEV(CE.ins); goto E1;
                endif;
                -- adr is address of an infix(PARQNT)
                if var(adr qua name(infix(PARQNT))).sem
                then adr:=var(adr qua name(infix(PARQNT))).ent
                        + var(adr qua name(infix(PARQNT))).fld;
                else EXPR:=true; goto E2 endif;
           endif;
           val:=var(adr qua name(infix(quant))).ent;
      endif;
E1:E2:end;
%title ***    C  O  M  M  A  N  D  S    ***
Routine DISPLAY_ATTRIBUTE;
begin Boolean star; star:=invariable;
      if errstat = 0 then DISPL_CE(star) endif;
end;

Routine DISPLAY_LOCALS;
begin CE.ins:=OP; CE.elt_kind:=EK_NO;
      repeat while FIND_NEXT do DISPL_CE(false) endrepeat;
end;

Routine DISPLAY_VISIBLES;
begin integer ncon; ref(instance) ins,conins;
      ref(pntvec) pnt_vec; Boolean blk;
      ins:=OP; blk:=true;
      repeat pnt_vec:=ins.pp.pnt_vec;
             if pnt_vec <> none
             then if blk then ncon:=pnt_vec.ncon else ncon:=0 endif;
                  repeat ncon:=ncon-1 while ncon >= 0
                  do conins:=var((ins+pnt_vec.pnt(ncon)) qua name(ref()));
                     if conins <> none
                     then ED_STR("*** Inspected ");
                          ED_BLKID(conins.pp); PRT(" ***");
                          CE.ins:=conins; CE.elt_kind:=EK_NO;
                          repeat while FIND_NEXT do DISPL_CE(false) endrepeat;
                     endif;
                  endrepeat;
             endif;
             ED_STR("*** "); ED_BLKID(ins.pp); PRT(" ***");
             CE.ins:=ins; CE.elt_kind:=EK_NO;
             repeat while FIND_NEXT do DISPL_CE(false) endrepeat;
             if    ins.sort=S_SUB then blk:=true
             elsif ins.sort=S_PRE then blk:=true
             elsif ins.sort=S_THK then blk:=true else blk:=false endif;
      while ins <> bio do ins:=ins.sl endrepeat;
end;

Routine DISPLAY_DYNAMIC_ENCLOSURES;
begin ref(instance) ins; PRT("Dynamic Enclosures:"); ins:=OP; ED_OP;
      repeat ins:=DYN(ins) while ins <> none
      do ED_AT_IN("    ",ins) endrepeat;
end;

Routine DISPLAY_OPERATING_CHAIN;
begin ref(instance) ins,x;
      if OP <> bio
      then PRT("Operating Chain:"); ins:=OP; ED_OP;
           repeat x:=DYN(ins) while ins <> bio
           do if x <> none then ins:=x
              else ED_STR("in the QPS-System"); ins:=ins.sl endif;
              ED_AT_IN("    ",ins);
           endrepeat;
      endif;
end;

Routine DISPLAY_TEXTUAL_ENCLOSURES;
begin ref(instance) ins; PRT("Textual Enclosures:"); ins:=OP; ED_OP;
      repeat while ins <> bio
      do ins:=ins.sl; ED_AT_IN("    ",ins) endrepeat;
end;

Routine ATTACH_LOGFILE;
begin integer key; infix(string) id;
      if bio.logfile <> 0
      then FAILED("You have already attached a logfile"); goto E endif;
L1:   id:=prompt("File_name: ",H_FNAM);
      if id.nchr > 0
      then key:=envir_OPEN(id,FIL_OUT,nostring,utlng);
           if status <> 0
           then status:=0; ED_OUT; ED_STR("The File "); ED_STR(id);
                PRT(" does not exist or is not accessible"); goto L1;
           endif;
           bio.logfile:=key;
      endif;
E:end;

Routine SET_LOGFILE; import Boolean sw;
begin if bio.logfile = 0 then FAILED("No logfile attached")
      else if bio.logfile<0 then bio.logfile:= -bio.logfile endif;
           if not sw then bio.logfile:= -bio.logfile endif;
      endif;
end;

Routine LIST_SOURCE;
begin integer key,lin,cnt; infix(string) id;
L1:   id:=prompt("File_name: ",H_FNAM);
      if id.nchr > 0
      then key:=envir_OPEN(id,FIL_IN,nostring,inlng);
           if status <> 0
           then status:=0; ED_OUT; ED_STR("The File "); ED_STR(id);
                PRT(" does not exist or is not accessible"); goto L1;
           endif;
           prompt("Start-line: ",0); lin:=innumber;
           prompt("Line-count: ",0); cnt:=innumber;
           LISTFIL(key,lin,cnt,0,0);
           envir_CLOSE(key,nostring); status:=0; utpos:=0;
      endif;
end;

Routine LIST_OBSERVER_POSITION;
begin integer key,lin,low; infix(string) filid,modid;
      ref(extptp) xpp; ref(identifier) filidt,modidt; ref(instance) ins;
      ins:=OP;
L1:   xpp:=ins.pp.xpp; if xpp=none then goto E1 endif;
      if xpp.blk_typ=BLK_THK then ins:=ins.sl; goto L1 endif;
      filidt:=xpp.mod_inf.source_file;
      if filidt=none then goto E2 endif;
      if filidt.ncha=0 then goto E3 endif;
      filid.nchr:=filidt.ncha; filid.chradr:= name(filidt.cha);
      if str_eq(filid,"SYSIN") then goto E4 endif;
      key:=envir_OPEN(filid,FIL_IN,nostring,inlng);
      if status <> 0
      then status:=0; ED_OUT; ED_STR("The File "); ED_STR(filid);
           PRT(" does not exist or is not accessible"); goto E5;
      endif;
      modidt:=xpp.mod_inf.mod_idt;
      if modidt=none then modid:=nostring
      elsif modidt.ncha=0 then modid:=nostring
      else modid.nchr:=modidt.ncha; modid.chradr:= name(modidt.cha) endif;
      lin:=GET_LINE_NO(OP.lsc); low:=LOWLIN(modid,lin);
      LISTFIL(key,lin-5,10,low,lin);
      envir_CLOSE(key,nostring); status:=0; utpos:=0;
E1:E2:E3:E4:E5:end;

Routine LOWLIN;
import infix(string) modid; integer lno; export integer res;
begin label prg,adr; integer lim;
      lim:=lno-10; if lim < 0 then lim:=0 endif;
      prg:=envir_GETPADDR(modid,lno); status:=0;
      repeat lno:=lno-1 while lno > lim
      do adr:=envir_GETPADDR(modid,lno);
         if status <> 0 then status:=0; goto E1 endif;
         if adr <> prg  then goto E2 endif;
      endrepeat;
E1:E2:res:=lno+1;
end;

Routine LISTFIL; import integer key,lin,cnt,fst,lst;
begin integer i,p; infix(string) img; boolean cont;
      if lin < 1 then lin:=1 endif; cont:=false;
      img.nchr:=utlng-10; img.chradr:=@utbuff(8);
      i:=0; repeat i:=i+1 while i < lin
      do envir_INIMAGE(key,img);
         if status <> 0 then
         if status=34 then i:=i-1; status:=0;
         else goto C1 endif endif; -- EOF or error
      endrepeat;
      i:=0; repeat i:=i+1 while i <= cnt
      do utpos:=0;
         if cont then ED_STR("        ")
         else ED_INT(lin);
              if (lin>=fst) and (lin<=lst)
              then ED_STR(":=>    ") else ED_STR(":      ") endif;
              lin:=lin+1;
         endif;
         utpos:=envir_INIMAGE(key,img) + 8;
         if status = 0 then cont:=false
         else if status <> 34 then goto C2   --- end-of-file or error
              else cont:=true; status:=0; i:=i-1 endif;
         endif;
         ED_OUT;
      endrepeat;
C1:C2:if status <> 0
      then utpos:=0;
           if status=13 then status:=0; PRT("End-of-file")
           else status:=0; PRT("Listing terminated due to file error") endif;
      endif;
end;

Routine LIST_OPEN_FILES;
begin ref(filent) F,N;
      N:=bio.fil_lst;
      repeat F:=N while F <> none
      do N:=F.suc;
         if    F=bio.sysin  then PRT("sysin")
         elsif F=bio.sysout then PRT("sysout")
         else  PRT(TXT_TO_STR(F.nam)) endif;
      endrepeat;
end;

Routine INPUT_DEVICE;
begin integer key; infix(string) id;
L1:   id:=prompt("File_name: ",H_FNAM);
      if id.nchr > 0
      then key:=envir_OPEN(id,FIL_IN,nostring,inlng);
           if status <> 0
           then status:=0; ED_OUT; ED_STR("The File "); ED_STR(id);
                PRT(" does not exist or is not accessible"); goto L1;
           endif;
           FAILED("NOT IMPLEMENTED YET"); envir_CLOSE(key,nostring); --- TEMP
      endif;
end;

Routine DISPLAY_ERROR_MESSAGE;
begin if RT_ERR then ED_ERR(er_no,er_fil,er_msg,er_msx,er_sts)
      else PRT("No error message given") endif;
end;

Routine DISPLAY_SIMBLK;
begin ref(instance) ins,old; ref(process) prc; ref(simulation) simblk;
      ins:=old:=OP;
      repeat while ins <> bio
      do if ins.sort = S_PRE
         then if ins.pp qua cla_pre_ptp.prefix(1) = ref(SMLPTP)
              then goto F endif;
         endif;
         ins:=ins.sl;
      endrepeat;
      FAILED("No SIMULATION-Block found"); goto E1;
F:    OP:=ins; ED_OP; DISPLAY_LOCALS;
      simblk:=ins;
      if simblk.sqs=none then prc:=none
      else prc:=simblk.sqs.bl endif; -- I.e. 'old' current
      if prc=simblk.sqs then PRT("SEQUENCING SET IS EMPTY"); goto E2;
      else PRT("*** SEQUENCING SET:") endif;
      repeat while prc <> none
      do ED_STR("Time "); ED_LREAL(prc.rnk);
         ED_STR("  -- "); ED_ENT_IDT(prc); ED_OUT;
         prc:=NEXTEV(prc);
      endrepeat;
E2:   OP:=old;
E1:end;
%title ***   N a v i g a t i o n    C o m m a n d s  ***

Routine MOVE_TO_ACTIVE_INSTANCE;
begin OP:=AI; ED_OP end;

Routine MOVE_TO_PREVIOUS_INSTANCE;
begin if (previns=none) or (OP <> AI) then MOVE_TO_DYNAMIC_ENCLOSURE
      else OP:=previns; ED_OP endif;
end;


Routine MOVE_TO_DYNAMIC_ENCLOSURE;
begin ref(instance) ins; ins:=DYN(OP);
      if ins = none then FAILED("No dynamic enclosure exists")
      else OP:=ins; ED_OP endif;
end;


Routine MOVE_TO_OBJECT;
begin ref(entity) obj;
      invariable; if errstat > 0 then goto E1 endif;
      if (CE.ELT_KIND <> EK_VAL) or (CE.atr_type <> T_REF)
      then SMB_ERR(curid," is not a reference"); goto E2 endif;
      obj:=EVAL_REF; if errstat > 0 then goto E3 endif;
      if obj=none then SMB_ERR(curid," == none"); goto E4 endif;
      CE.elt_kind:=EK_NO; CE.ins:=obj;
      OP:=CE.ins; ED_OP;
E1:E2:E3:E4:end;


Routine MOVE_TO_TEXTUAL_ENCLOSURE;
begin if OP = bio then FAILED("No textual enclosure exists")
      else OP:=OP.sl; ED_OP endif;
end;


Routine MOVE_TO_TOP; -- Set CE to head of QPS component
begin ref(instance) ins;
      repeat ins:=DYN(OP) while ins <> none do OP:=ins endrepeat;
      ED_OP;
end;
%title ***  B r e a k    P o i n t    H a n d l i n g  ***
Routine OBSERVE_STATEMENT;
begin Boolean found; integer free,i,lno;
      infix(PROGPNT) BRK; infix(string) modid;
      found:=false; prompt("Program-point: ",H_PROG);
      if LETTER(nextbyte)
      then inidentifier; if errstat > 0 then goto E1 endif; modid:=curid;
           if getbyte <> ':' then FAILED("Missing colon"); goto E2 endif;
      else modid:=nostring endif;
      lno:=innumber; BRK.count:=0;
      if moreinfo then prompt("Skip-count: ",0); BRK.count:=innumber endif;
      if BRK.count < 0 then BRK.count:=0 endif;
      if nbreaks=max_break
      then FAILED("Too many events defined"); goto E3 endif;

      -- Let Environment set break point, and make sure no troubles.;
      BRK.paddr:=envir_GETPADDR(modid,lno); if status <> 0
      then FAILED("Can't find program point"); goto E4 endif;
      lno:=envir_GET_LINE_NO(BRK.paddr); if status <> 0
      then FAILED("Can't find program point"); goto E5 endif;

      -- Look for a free entry --
      i:=0; repeat i:=i+1 while not found and (i < max_break)
      do if stmnt(i).paddr=nowhere then found:=true; free:=i endif endrepeat;
      if not found then FAILED("Statement break table is full"); goto E6 endif;

      i:=0; repeat i:=i+1 while i < max_break
      do if stmnt(i).paddr=BRK.paddr
         then FAILED("Statement break is already set"); goto E7 endif;
      endrepeat

      envir_BREAK(BRK.paddr,true); -- environment sets breakpoint
      if status <> 0
      then if    status=36 then FAILED("Statement break table is full")
           elsif status=37 then FAILED("Breakpoint set had no effect")
           else FAILED("Unable to set breakpoint") endif;
           goto E8;
      endif;
      stmnt(free):=BRK; -- Insert the supplied statement event in the table.;
      ED_STR("Break number "); ED_INT(free); ED_STR(" is attached to line ");
      ED_MODLINE(BRK.paddr);
      if BRK.count > 0 then ED_STR(" with count "); ED_INT(BRK.count) endif;
      if SYSMODE then ED_STR("   Break address: "); ED_PADDR(BRK.paddr) endif;
      ED_OUT; nbreaks:=nbreaks+1;
E1:E2:E3:E4:E5:E6:E7:E8:end;


Routine CANCEL_STATEMENT;
begin integer i; i:=0;
      prompt("Break_number: ",H_BRK);
      if LETTER(nextbyte)
      then inidentifier;
           if match(curid,"ALL")
           then repeat i:=i+1 while nbreaks > 0 do
                if stmnt(i).paddr <> nowhere then kancel(i) endif endrepeat;
           else SMB_ERR("Illegal break_number: ",curid) endif;
      else kancel(innumber) endif; -- remove single break point;
end;

Routine kancel; import integer i;
begin ref(identifier) ident; infix(string) modid; label paddr;
      if i < 0 then goto F1 elsif i >= max_break then goto F2 endif;
      if stmnt(i).paddr = nowhere then goto F3 endif;
      -- Call upon RTS to actually remove the break point.;
      envir_BREAK(stmnt(i).paddr,false);     -- removes breakpoint
      if status <> 0 then status:=0; goto F4 endif;
      -- Remove the entry from the statement table.;
      stmnt(i).paddr:=nowhere;
      stmnt(i).count:=0; nbreaks:=nbreaks-1; goto E;
F1:F2:F3:F4:FAILED("No statement attached to this break number");
E:end;

Routine LIST_OBSERVED_STATEMENTS;
begin integer i;   -- statement table index;
      integer listed;  -- nr. of processed entries;
      if nbreaks = 0 then PRT("NO STATEMENTS ARE BEING OBSERVED.")
      else PRT("STATEMENTS BEING OBSERVED:"); i:=0; listed:=0;
           repeat i:=i+1 while listed < nbreaks
           do if stmnt(i).paddr <> nowhere
              then ED_STR("Break number "); ED_INT(i);
                   ED_STR(" is attached to line ");
                   ED_MODLINE(stmnt(i).paddr);
                   if stmnt(i).count > 0
                   then ED_STR(" with count "); ED_INT(stmnt(i).count) endif;
                   if SYSMODE
                   then ED_STR("   Break address: ");
                        ED_PADDR(stmnt(i).paddr);
                   endif;
                   ED_OUT; listed:=listed + 1;
              endif;
           endrepeat;
      endif;
end;

Routine LIST_OBSERVED_EVENTS;
begin
      if CNT(EVT_BEG) >= 0
      then PRT("OBSERVE-INSTANCE-GENERATION") endif;
      if CNT(EVT_GOTO) >= 0
      then PRT("OBSERVE-CONTROL-FLOW") endif;
      if CNT(EVT_QPS) >= 0
      then PRT("OBSERVE-SEQUENCING") endif;
      if CNT(EVT_ARR) >= 0
      then PRT("OBSERVE-ARRAY-CREATION") endif;
      if CNT(EVT_TXT) >= 0
      then PRT("OBSERVE-TEXT-GENERATION") endif;
      if CNT(EVT_SNAP) >= 0
      then PRT("OBSERVE-SNAPSHOT") endif;
      if CNT(EVT_FIL) >= 0
      then ED_STR("OBSERVE-FILE-EVENTS");
           if FTRCNT(FTR_OPEN)>=0 then ED_STR(" open") endif;
           if FTRCNT(FTR_CLOS)>=0 then ED_STR(" close") endif;
           if FTRCNT(FTR_INIM)>=0 then ED_STR(" inimage") endif;
           if FTRCNT(FTR_UTIM)>=0 then ED_STR(" outimage") endif;
           if FTRCNT(FTR_LOCA)>=0 then ED_STR(" locate") endif;
           if FTRCNT(FTR_ENDF)>=0 then ED_STR(" endfile") endif;
           ED_OUT;
      endif;
      if CNT(EVT_SML) >= 0
      then ED_STR("OBSERVE-SIMULATION-EVENTS");
           if SMLCNT(SML_ACTI)>=0 then ED_STR(" activate") endif;
           if SMLCNT(SML_PASS)>=0 then ED_STR(" passivate") endif;
           if SMLCNT(SML_CANC)>=0 then ED_STR(" cancel") endif;
           if SMLCNT(SML_WAIT)>=0 then ED_STR(" wait") endif;
           if SMLCNT(SML_HOLD)>=0 then ED_STR(" hold") endif;
           ED_OUT;
      endif;
      if CNT(EVT_GC) >= 0
      then ED_STR("OBSERVE-GARBAGE-COLLECTOR");
           if GC_CNT(GC_BEG)>=0 then ED_STR(" start") endif;
           if GC_CNT(GC_END)>=0 then ED_STR(" finish") endif;
           ED_OUT;
      endif;
end;

Routine OBSERVE_CNT; import integer evt,i;
begin if evt > 0 then CNT(evt):=i
      else if i > 0 then i:=0 endif;
           CNT(EVT_BEG):=i;
           CNT(EVT_END):=i;
           CNT(EVT_GOTO):=i;
      endif;
      bio.trc:=false; i:=EVT_BEG - 1;
      repeat i:=i+1 while i <= EVT_SNAP
      do if CNT(i) >= 0 then bio.trc:=true endif endrepeat;
end;

Routine OBSERVE_SML;
begin integer evt,cnt;
L1:L2:prompt("Event: ",H_SML); inidentifier;
      if str_eq(curid,"ALL") then evt := -1
      elsif match(curid,"ACTIVATE")  then evt:=SML_ACTI
      elsif match(curid,"PASSIVATE") then evt:=SML_PASS
      elsif match(curid,"CANCEL")    then evt:=SML_CANC
      elsif match(curid,"WAIT")      then evt:=SML_WAIT
      elsif match(curid,"HOLD")      then evt:=SML_HOLD
      else FAILED("Illegal event spesification"); goto L1 endif;
      cnt:=incond;
      if evt >= 0 then SMLCNT(evt):=cnt
      else SMLCNT(SML_ACTI):=cnt; SMLCNT(SML_PASS):=cnt;
           SMLCNT(SML_CANC):=cnt; SMLCNT(SML_WAIT):=cnt;
           SMLCNT(SML_HOLD):=cnt;
      endif;
      if moreinfo then goto L2 endif;
      evt:= -1; cnt:= -1;
      repeat evt:=evt+1 while evt < SML_max
      do if SMLCNT(evt) >= 0 then cnt:=0 endif endrepeat;
      OBSERVE_CNT(EVT_SML,cnt);
end;

Routine OBSERVE_FIL;
begin integer evt,cnt;
L1:L2:prompt("Event: ",H_FIL); inidentifier;
      if str_eq(curid,"ALL") then evt := -1
      elsif match(curid,"OPEN")     then evt:=FTR_OPEN
      elsif match(curid,"CLOSE")    then evt:=FTR_CLOS
      elsif match(curid,"INIMAGE")  then evt:=FTR_INIM
      elsif match(curid,"OUTIMAGE") then evt:=FTR_UTIM
      elsif match(curid,"LOCATE")   then evt:=FTR_LOCA
      elsif match(curid,"ENDFILE")  then evt:=FTR_ENDF
      else FAILED("Illegal event spesification"); goto L1 endif;
      cnt:=incond;
      if evt >= 0 then FTRCNT(evt):=cnt
      else FTRCNT(FTR_OPEN):=cnt; FTRCNT(FTR_CLOS):=cnt;
           FTRCNT(FTR_INIM):=cnt; FTRCNT(FTR_UTIM):=cnt;
           FTRCNT(FTR_LOCA):=cnt; FTRCNT(FTR_ENDF):=cnt;
      endif;
      if moreinfo then goto L2 endif;
      evt:= -1; cnt:= -1;
      repeat evt:=evt+1 while evt < FTR_max
      do if FTRCNT(evt) >= 0 then cnt:=0 endif endrepeat;
      OBSERVE_CNT(EVT_FIL,cnt);
end;

Routine OBSERVE_GC;
begin integer evt,cnt;
L1:L2:prompt("Event: ",H_GC); inidentifier;
      if str_eq(curid,"ALL") then evt := -1
      elsif match(curid,"START")  then evt:=GC_BEG
      elsif match(curid,"FINISH") then evt:=GC_END
      elsif match(curid,"PASS1")  then evt:=GC_EP1
      elsif match(curid,"PASS2")  then evt:=GC_EP2
      elsif match(curid,"PASS3")  then evt:=GC_PRC3
      elsif match(curid,"FOLLOW") then evt:=GC_PRC1
      elsif match(curid,"UPDATE") then evt:=GC_UPD3
      else FAILED("Illegal event spesification"); goto L1 endif;
      cnt:=incond;
      if evt >= 0 then GC_CNT(evt):=cnt
      else GC_CNT(GC_BEG):=cnt;  GC_CNT(GC_END):=cnt;
           GC_CNT(GC_EP1):=cnt;  GC_CNT(GC_EP2):=cnt;
           GC_CNT(GC_PRC1):=cnt; GC_CNT(GC_PRC3):=cnt;
           GC_CNT(GC_UPD3):=cnt;
      endif;
      if moreinfo then goto L2 endif;
      evt:= -1; cnt:= -1;
      repeat evt:=evt+1 while evt < GC_max
      do if GC_CNT(evt) >= 0 then cnt:=0 endif endrepeat;
      OBSERVE_CNT(EVT_GC,cnt);
end;
%title ***   A t t r i b u t e    S e a r c h   ***
Routine FIND_IDENT;
import ref(instance) ins; infix(string) ident; export Boolean found;
-- Search for an attribute named 'ident' starting with 'ins' and following
-- 'ins.sl' i.e. textual enclosures.
-- Whenever an instance is searched, the deepest nested connected instance
-- is searched first, the instance itself last.
begin integer ncon; ref(instance) conins; ref(pntvec) pnt_vec; Boolean blk;
      blk:=true;
      repeat pnt_vec:=ins.pp.pnt_vec;
             if pnt_vec <> none
             then if blk then ncon:=pnt_vec.ncon else ncon:=0 endif;
                  repeat ncon:=ncon-1 while ncon >= 0
                  do conins:=var((ins+pnt_vec.pnt(ncon)) qua name(ref()));
                     if conins <> none
                     then if FIND_ATTR(conins,ident)
                          then found:=true; goto E1 endif;
                     endif;
                  endrepeat;
             endif;
             if FIND_ATTR(ins,ident) then found:=true; goto E2 endif;
             if    ins.sort=S_SUB then blk:=true
             elsif ins.sort=S_PRE then blk:=true
             elsif ins.sort=S_THK then blk:=true else blk:=false endif;
      while ins <> bio do ins:=ins.sl endrepeat;
      found:=false;
E1:E2:end;


Routine FIND_ATTR; -- Find an attribute named 'ident' in the instance 'ins'.
import ref(instance) ins; infix(string) ident; export Boolean found;
begin integer x,plv; ref(extptp) xpp; ref(atrvec) avec;
      case 0:MAX_SORT (ins.sort)
      when S_ATT,S_DET,S_RES,S_TRM,S_PRE: plv:=ins.pp qua cla_pre_ptp.plv;
           repeat xpp:=ins.pp qua cla_pre_ptp.prefix(plv).xpp;
                  if xpp=none then MISS:=true; goto L1 endif;
                  if xpp.mod_inf.smb_lvl < 2 then MISS:=true endif;
                  avec:=xpp.atr_vec; x:=SEARCH_ATRVEC(avec,ident);
                  if x >= 0 then goto F1 endif;
      L1:  while plv > 0 do plv:=plv - 1  endrepeat;
      when S_SUB,S_PRO:
           xpp:=ins.pp.xpp; if xpp=none then MISS:=true; goto N1 endif;
           if xpp.mod_inf.smb_lvl < 2 then MISS:=true endif;
           if xpp.blk_typ <> BLK_SUB
           then avec:=ins.pp qua pro_ptp.par_vec; x:=SEARCH_ATRVEC(avec,ident);
                if x >= 0 then plv:=1; goto F2 endif;
           endif;
           avec:=xpp.atr_vec; x:=SEARCH_ATRVEC(avec,ident);
           if x >= 0 then plv:=0; goto F3 endif;
      endcase;
N1:   CE.elt_kind:=EK_NO; found:=false; goto E;  --- No attribute found ---
F1:F2:F3:case 0:MAX_KIND (avec.atr(x).kind) --- Attribute found    ---
      when K_CLA: CE.elt_kind:=EK_CLA
      when K_PRO: CE.elt_kind:=EK_PRO
      when K_LAB: CE.elt_kind:=EK_LAB
      when K_SWT: CE.elt_kind:=EK_SWT
      when K_ARR: CE.elt_kind:=EK_ARR; CE.nind:=0;
      otherwise   CE.elt_kind:=EK_VAL   endcase;
      CE.atr_vec:=avec; CE.atr_type:=avec.atr(x).type;
      CE.idx:=x; CE.plv:=plv; CE.ins:=ins; found:=true;
E:end;
%page

Routine FIND_NEXT; export Boolean found; -- Find 'next' attribute in CE.ins
begin integer x,plv,ek; ref(extptp) xpp; ref(atrvec) avec; ref(instance) ins;
      ins:=CE.ins; ek:=CE.elt_kind; x:=CE.idx+1;
      case 0:MAX_SORT (ins.sort)
      when S_ATT,S_DET,S_RES,S_TRM,S_PRE:
           if ek <> EK_NO then plv:=CE.plv
           else plv:=ins.pp qua cla_pre_ptp.plv endif;
           repeat xpp:=ins.pp qua cla_pre_ptp.prefix(plv).xpp;
                  if xpp=none then MISS:=true; goto L1 endif;
                  if xpp.mod_inf.smb_lvl < 2 then MISS:=true endif;
                  avec:=xpp.atr_vec;
                  if avec <> none
                  then if ek=EK_NO then x:=0; goto F1
                       elsif x < avec.natr then goto F2 endif;
                  endif;
      L1:  while plv > 0 do plv:=plv - 1  endrepeat;
      when S_SUB,S_PRO:
           if ek <> EK_NO then plv:=CE.plv
           else plv:=if ins.sort=S_PRO then 1 else 0 endif;
           xpp:=ins.pp.xpp; if xpp=none then MISS:=true; goto P1 endif;
           if xpp.mod_inf.smb_lvl < 1 then MISS:=true endif;
       P1: if plv = 1
           then avec:=ins.pp qua pro_ptp.par_vec;
                if avec <> none
                then if ek=EK_NO then x:=0; goto F3;
                     elsif x < avec.natr then goto F4 endif;
                     ek:=EK_NO;
                endif;
           endif;
           plv:=0; if xpp = none then goto N1 endif;
           avec:=xpp.atr_vec; if avec=none then goto N2 endif;
           if ek=EK_NO then x:=0; goto F5;
           elsif x < avec.natr then goto F6 endif;
      endcase;
N1:N2:CE.elt_kind:=EK_NO; found:=false; goto E;           --- No attribute found
F1:F2:F3:F4:F5:F6:case 0:MAX_KIND (avec.atr(x).kind) --- Attribute found
      when K_CLA: CE.elt_kind:=EK_CLA
      when K_PRO: CE.elt_kind:=EK_PRO
      when K_LAB: CE.elt_kind:=EK_LAB
      when K_SWT: CE.elt_kind:=EK_SWT
      when K_ARR: CE.elt_kind:=EK_ARR; CE.nind:=0;
      otherwise   CE.elt_kind:=EK_VAL   endcase;
      CE.atr_vec:=avec; CE.atr_type:=avec.atr(x).type;
      CE.idx:=x; CE.plv:=plv; found:=true;
E:end;
%page

Routine SEARCH_ATRVEC;
import ref(atrvec) atr_vec; infix(string)  aid;
export integer index;
-- Search in atr_vec for an attribute associated with aid.
-- If found, atr_vec.atr(index) will be corresponding
-- atrdes. If not found, index is set equal to -1.
begin integer lng,natr,pos; ref(identifier) idt;
      if atr_vec = none then goto E1 endif;
      natr:=atr_vec.natr; index:=0;
      repeat idt:=atr_vec.atr(index).ident; lng:=aid.nchr;
             if idt=none then MISS:=true; goto E2 endif;
             if lng = idt.ncha
             then pos:=0;
                  repeat if idt.cha(pos) <> var(aid.chradr)(pos)
                         then goto NEXT endif; -- unequal
                         pos:=pos + 1;
                  while pos < lng do endrepeat;
                  goto E3; -- identifiers are equal !
             endif;

      NEXT:  index:=index + 1;
      while  index < natr do endrepeat;
E1:E2:index:= -1; -- indicates identifier not found
E3:end;
%title ***   U t i l i t y    R o u t i n e s   ***

Routine match; import infix(string) t1,t2; export Boolean res;
begin character c1,c2; integer i,j;
      c1:=c2:='?'; i:=j:=0; res:=false;
      repeat while c1 = c2
      do if i < t1.nchr then c1:=var(t1.chradr)(i); i:=i+1;
                        else res:=true; goto E1 endif;
         if j < t2.nchr then c2:=var(t2.chradr)(j); j:=j+1;
                        else goto E2 endif;
         if (c1='-') or (c2='-')
         then repeat while c1 <> '-'
              do if i < t1.nchr then c1:=var(t1.chradr)(i); i:=i+1;
                           else res:=true; goto E3 endif endrepeat;
              repeat while c2 <> '-'
              do if j < t2.nchr then c2:=var(t2.chradr)(j); j:=j+1;
                           else goto E4 endif endrepeat;
         endif;
      endrepeat;
E1:E2:E3:E4:end;

Routine str_eq; import infix(string) t1,t2; export Boolean res;
begin integer i;
      i:=t1.nchr; res:=false; if i <> t2.nchr then goto E1 endif;
      repeat i:=i-1; while i >= 0 do
      if var(t1.chradr)(i) <> var(t2.chradr)(i) then goto E2 endif endrepeat;
      res:=true;
E1:E2:end;

Routine DYN; import ref(instance) ins; export ref(instance) res;
begin if ins <> none
      then case 0:MAX_SORT (ins.sort)
           when S_TRM,S_DET,S_RES,S_PRE: ins:=none -- no dynamic encl.
           otherwise repeat ins:=ins.dl while ins.lsc=nowhere do endrepeat
           endcase;
      endif; res:=ins;
end;

Routine ED_AT_IN; import infix(string) op; ref(instance) ins;
-- Display a system point and possibly the state of its instance;
begin ED_STR(op); ED_STR("at "); ED_LSC(ins);
      ED_STR("  in "); ED_ENT_IDT(ins); ED_OUT;
end;

Routine ED_OP; begin ED_AT_IN("OP  ",OP) end;

Routine ED_PREFIX; import ref(cla_pre_ptp) pp;
begin ref(extptp) xpp;  if pp.plv > 0
      then xpp:=pp.prefix(pp.plv-1).xpp;
           if xpp=none then ED_STR("Prefix") else ED_IDT(xpp.idt) endif;
      endif;
end;

Routine ED_BLKID; import ref(ptp) pp;
begin ref(extptp) xpp; if pp=none then xpp:=none else xpp:=pp.xpp endif;
      if xpp <> none
      then case 0:MAX_BLK (xpp.blk_typ)
           when BLK_PRE: ED_PREFIX(pp); ED_STR("-Block");
           when BLK_CLA: if pp qua ref(cla_pre_ptp).plv > 0
                         then ED_PREFIX(pp); ED_SKIP(1) endif;
                         ED_STR("Class "); ED_IDT(xpp.idt);
           when BLK_FNC,BLK_PRO:   --   ED_TYP(xpp.typ,xpp.qal);
                         ED_STR("Procedure "); ED_IDT(xpp.idt);
           when BLK_SUB: ED_STR("Sub-Block "); ---  ED_IDT(xpp.idt);
           endcase;
      else ED_IDT(none) endif;
end;


Routine SMB_ERR; import infix(string) ms1,ms2;
begin status:=0; ED_OUT; ED_STR("*** ERROR *** ");
      ED_STR(ms1); PRT(ms2); errstat:=1;
end;

Routine FAILED; import infix(string) ms; begin SMB_ERR(nostring,ms) end;


Routine help; import infix(string) id; integer n;
begin integer i; i:=0;
      case 0:H_max (n)
 when H_CMND: repeat if match(id,CMID(i)) then PRT(CMID(i)) endif; i:=i+1;
              while i < C_max do endrepeat;
 when H_VAR:  PRT("The syntax of a variable is:");
              PRT("   variable ::= simple < . simple >* < . * >?");
              PRT("   simple   ::= identifier < ( index < , index >* ) >?");
              PRT("   index    ::= identifier  !  integer");
 when H_PROG: PRT("The syntax of a program_point is:");
              ED_STR("   program-point ::= <module-ident : >?");
              PRT("  line_number  <count_number>?");
              PRT("   module_ident   ::= identifier");
              PRT("   line_number   ::= integer");
 when H_BRK:  PRT("The syntax of a break_number is:");
              PRT("   break_number ::= integer  !  ALL");
 when H_FNAM: PRT("The syntax of a file_name is dependent upon");
              PRT("the Operating System you are executing under.");
              PRT("  ---  Please check it in the manual  ---");
 when H_FIL:  PRT("The syntax of a FILE event is:");
              PRT("   event ::= ALL ! OPEN ! CLOSE ! INIMAGE !");
              PRT("             OUTIMAGE ! LOCATE ! ENDFILE");
 when H_SML:  PRT("The syntax of a SIMULATION event is:");
              ED_STR("   event ::= ALL ! ACTIVATE ! PASSIVATE !");
              PRT(" HOLD ! WAIT ! CANCEL");
 when H_GC:   PRT("The syntax of a GARBAGE COLLECTOR event is:");
              PRT("   event ::= ALL ! START ! FINISH ! PASS1 ! PASS2");
              PRT("             PASS3 ! FOLLOW ! UPDATE");
 when H_COND: PRT("The syntax of an event-CONDITION is:");
              PRT("   condition ::= ON ! OFF ! SKIP count'number");
    otherwise PRT("Sorry, no help information available") endcase;
end;
%title ***  I N P U T     H a n d l i n g  ***

Routine prompt; import infix(string) ms; integer hn; export infix(string) R;
begin integer p,i,n,lng; character c; Boolean question;
      inpos:=inlim+1;
L1:   R:=nostring; lng:=0; question:=false;
L2:L3:if inpos < inline.nchr
      then p:=inpos; c:=inbuff(p); inpos:=p+1;
           if c=' ' then goto L3 endif;
           if c='?' then question:=true; goto L5 endif;
           lng:=1;
     L4:   if inpos < inline.nchr
           then c:=inbuff(inpos); inpos:=inpos+1;
                if c='?' then question:=true endif;
                if (c <> ' ') and (c <> ',') and (c <> '?')
                then lng:=lng+1; goto L4 endif;
           endif;
           R.chradr:=@inbuff(p); R.nchr:=lng;
      endif;
L5:   if SMB_TRC
      then ED_STR("NEXTITEM: ^"); ED_STR(R); ED_STR("^ ");
           if question then ED_CHAR('?') endif; ED_OUT;
      endif;

      if question then question:=false; help(R,hn); goto L1 endif;
      if lng > 0 then inpos:=p; inlim:=p+lng;
      else n:=inline.nchr; inline.chradr:=@inbuff; inline.nchr:=inlng;
      L6:  i:=envir_SYSPROMPT(ms,inline); inpos:=0;
           if status <> 0
           then if status=13 then status:=0; PRT("EOF on sysin"); SMB_TERM;
                elsif status=12
                then status:=0; PRT("Too long input"); goto L6 endif;
                status:=0; i:=0; IERR("PROMPT-1");
           endif;
           if i > 0 then inline.nchr:=i else inline.nchr:=n endif;
           if bio.logfile>0 then envir_OUTIMAGE(bio.logfile,inline) endif;
           if status <> 0 then status:=0; IERR("PROMPT-2") endif;
           if inline.nchr <> 0
           then p:=inline.nchr;
                repeat p:=p-1 while p >= 0
                do i:=inbuff(p) qua integer;
                   if i > 127 then i:=i-128 endif;
                   if i > 95  then i:=i-32  endif;
                   inbuff(p):=i qua character;
                endrepeat;
                goto L2;
           endif;
      endif;
end;


Routine command_no; import infix(string) id; export integer res;
begin integer k,i,n; n:=i:=0; res:=0;
      repeat if match(id,CMID(i))
             then k:=i; n:=n+1; if str_eq(id,CMID(i)) then goto E endif endif;
             i:=i+1;
      while i < C_max do endrepeat;
      if n=1 then E: res:=k+1 endif;
end;
%page

Routine moreinfo; export Boolean res;
begin integer p; p:=inpos-1; res:=false;
      repeat p:=p+1 while p < inline.nchr
      do if inbuff(p) <> ' ' then res:=true; goto E endif endrepeat;
E:end;

Routine nextbyte; export character c;
begin if inpos < inlim
      then c:=inbuff(inpos) else c:='@' endif;
end;

Routine getbyte; export character c;
begin if inpos < inlim
      then c:=inbuff(inpos); inpos:=inpos+1 else c:='@' endif;
end;

Routine number; export Boolean res;
begin character x; x:=nextbyte;
      res:= (x='+') or (x='-') or DIGIT(x);
end;

Routine innumber; export integer i;
begin infix(string) s;
      s.chradr:=@inbuff(inpos); s.nchr:=inlim-inpos;
      i:=envir_GETINT(s);
      if status <> 0 then FAILED("Illegal number")
      else inpos:=inpos+itemsize
           if SMB_TRC then ED_STR("INNUMBER:"); ED_INT(i); ED_OUT endif;
      endif;
end;


Routine inidentifier; export infix(string) res;
begin integer p,lng; character c; p:=inpos; lng:=0;
      if not LETTER(nextbyte) then FAILED("Missing identifier"); goto E endif;
      repeat c:=nextbyte while LETTER(c) or DIGIT(c) or (c='_')
      do getbyte; lng:=lng+1 endrepeat;
      curid.chradr:=@inbuff(p); curid.nchr:=lng; res:=curid;
      if SMB_TRC then ED_STR("INIDENTIFIER: "); PRT(curid) endif;
E:end;

Routine inonoff; export Boolean res;
begin res:=false;
  L1: prompt("Enter ON or OFF: ",0); inidentifier;
      if str_eq(curid,"ON") then res:=true
      elsif not str_eq(curid,"OFF") then goto L1 endif;
end;

Routine incond; export integer res;
begin res:=0;
L:    prompt("Condition: ",H_COND); inidentifier;
      if    str_eq(curid,"ON")     then res := 0
      elsif match(curid,"OFF")     then res := -1
      elsif match(curid,"SKIP")    then prompt("Number: ",0); res:=innumber
      else goto L endif;
end;
%title ***  B e g i n / E n d    U s e r    P r o g r a m  ***

--------   M O D U L E    I N F O   ---------

const infix(modinf) BASMOD=record:modinf(mod_idt=ref(RTSIDT),smb_lvl=2);

DEFINE_IDENT(%RTSIDT%,%8%,%('R','T','S','.','M','N','T','R')%);

---------   C l a s s    S Y S T E M   ---------

 const infix(cla_pre_ptp:2) SYSTEMPTP=record:cla_pre_ptp
       (plv=0,lng = size(instance),pnt_vec=none,xpp=none,
         dcl=nowhere,stm=nowhere,cnt_inr=nowhere,
         prefix =(ref(SYSTEMPTP),none));


---------   C l a s s    B A S I C I O   ---------

 visible const infix(cla_pre_ptp:2) BASICIOPTP=record:cla_pre_ptp
       (plv=0,lng = size(basicio),pnt_vec=ref(BIOPNT),xpp=ref(BIOXPP),
         dcl=BIODCL,stm=BIOSTM,cnt_inr=BIOINR,
         prefix =(ref(BASICIOPTP),none));

 const infix(pntvec:4) BIOPNT=record:pntvec
       (npnt=4,pnt=(field(basicio.sysin),field(basicio.sysout),
                    field(basicio.ern.ins),field(basicio.erh.sl)));
const infix(extptp) BIOXPP=record:extptp
   (idt=ref(BIOIDT),mod_inf=ref(BASMOD),atr_vec=ref(BIOATR),blk_typ=BLK_CLA);

const infix(atrvec:2) BIOATR=record:atrvec
   (natr=2,atr=(ref(BA_SYSIN),ref(BA_SYSOUT)));

SIMPLE_ATTR(%BA_SYSIN%,%ID_SYSIN%,%basicio.sysin%,%T_REF%);
SIMPLE_ATTR(%BA_SYSOUT%,%ID_SYSOUT%,%basicio.sysout%,%T_REF%);

DEFINE_IDENT(%BIOIDT%,%7%,%('B','A','S','I','C','I','O')%);
DEFINE_IDENT(%ID_SYSIN%,%5%,%('S','Y','S','I','N')%);
DEFINE_IDENT(%ID_SYSOUT%,%6%,%('S','Y','S','O','U','T')%);

%page
Visible routine B_PROG;
import ref(cla_pre_ptp) bio_ptp;        --  Prototype of BASICIO.
exit label psc;
begin ref(instance) sys; integer i;
      ---  IMPORTANT: do NOT call any error routine before curins is set  ---
      act_lvl:=ACT_INI; bio:=curins:=none; status:=0; utpos:=0;
      pgsize:=24; pgleft:=pgsize; SYSMODE:=false;
      err_ini:=entry(inierr); smb:=entry(SIMOB); -- For error diagnostics.
      envir_INIT(entry(exchdl));                -- Exception handler.
--    if status <> 0 then  ERR_SYS  endif;  -- status error taken in STRG_INIT
      maxlen:= none + maxlen + size(savent) - none;
      ---  Compute how much storage we must allocate for the predefined
      ---  enclosing instances, create initial storage pool and initialize
      ---  the pool structure. Also set 'bio' to point to start of the pool.
      STRG_INIT(none + SYSTEMPTP.lng + bio_ptp.lng             -- TEMP
                 + PFILPTP.lng + PFILPTP.lng + FILPTP.lng
                 + size(txtent:ouptlinelng) + size(txtent:inptlinelng)
                 - none);
      bio.pool_nxt:=bio.pool_nxt + bio_ptp.lng;
      bio.sort:=S_PRE; bio.pp:=bio_ptp;
      bio.ini_tim:=GET_CPU_TIME; bio.lsc:=BIODCL;
      ---  Create the outermost prefixed block instance.
      ---  This instance will enclose BASICIO.
      sys:=bio.pool_nxt;
      bio.pool_nxt:=bio.pool_nxt + SYSTEMPTP.lng;
      sys.sort:=S_PRE; sys.pp:=ref(SYSTEMPTP);
      sys.lsc:=psc;    --  So that we know where the user program is!
      bio.sl:=bio.dl:=sys; curins:=bio;
      ---  NOW when curins is set, normal error exits can be taken
      i:=0; repeat while i < EVT_max do    CNT(i):= -1; i:=i+1 endrepeat;
      i:=0; repeat while i < FTR_max do FTRCNT(i):= -1; i:=i+1 endrepeat;
      i:=0; repeat while i < SML_max do SMLCNT(i):= -1; i:=i+1 endrepeat;
      i:=0; repeat while i < GC_max  do GC_CNT(i):= -1; i:=i+1 endrepeat;
      bio.maxint:=maxint;        bio.minint:=minint;
      bio.maxreal:=maxreal;      bio.minreal:=minreal;
      bio.maxlreal:=maxlreal;    bio.minlreal:=minlreal;
      bio.maxrank:=maxrank;  --- bio.simid:-" Some string ";
      bio.lwten:='&'; envir_LTEN('&');   -- if status <> 0 then ERR_SYS endif;
      bio.dcmrk:='.'; envir_DCMARK('.'); if status <> 0 then ERR_SYS endif;

      psc:=BIODCL;       --  See next subsection, on the
                          --  page after the next page.
end;


Routine SYS_FIL_SPC;
import range(1:3) code; export infix(txtqnt) txt;
begin integer n; n:=envir_DSETSPEC(code,STRBUF(0));
      if status <> 0 then ERR_SYS endif;
      txt:=BLANKS(n); C_MOVE(STRBUF(n),TXT_TO_STR(txt));
end;


Visible routine  E_PROG;
import range(0:MAX_TRM) trm; infix(string) dummy;
begin ref(filent) F,N;
      if bio.sysout.img.cp > bio.sysout.img.sp then OUTIMAGE(bio.sysout) endif;
      if trm=TRM_NRM then
         if envir_GET_INTINFO(19)>0 then
            TRC_EPRG;STRG_TERM; bio.trc:=false endif;
         if status<>0 then status:=0 endif;
      endif;
      if bio.edt_ovf > 0
      then ED_OUT; ED_STR("No. of text edit overflows: ");
           ED_INT(bio.edt_ovf); ED_OUT;
      endif;
      act_lvl:=ACT_TRM; bio.trc:=false; N:=bio.fil_lst;
      repeat F:=N while F <> none
      do N:=F.suc; if F=bio.sysin then elsif F=bio.sysout then
         else ED_STR("The file "); ED_STR(TXT_TO_STR(F.nam));
              ED_STR(" was open at program termination.");
              PRT(" Closed by Simula Runtime System."); CLOSE(F);
         endif;
      endrepeat;
      if bio.logfile > 0 then envir_CLOSE(bio.logfile,nostring)
      elsif bio.logfile < 0 then envir_CLOSE(-bio.logfile,nostring) endif;
      CLOSE(bio.sysin); CLOSE(bio.sysout); envir_TERM(trm,nostring);
end;

Visible routine ERRX; import infix(txtqnt) mss;
begin infix(string) str;   --  TXT_TO_STR(img).
      str.nchr:=mss.lp-mss.sp; str.chradr:=name(mss.ent.cha(mss.sp));
      PRT(str); ERROR(ENO_SYS_1);
end;

Visible routine TRMP;
begin E_PROG(TRM_REQ,nostring) end;
%page
%visible
 BIODCL:  BIOSTM:  ---  We get here only once, when exiting from B_PROG.

    ---  Create and open sysout.
    B_CLA(bio,ref(PFILPTP)); bio.sysout:=tmp.pnt;
    bio.sysout.nam:=SYS_FIL_SPC(2);
    OPEN(bio.sysout,BLANKS(ouptlinelng));

    ---  Create and open sysin.
    B_CLA(bio,ref(IFILPTP)); bio.sysin:=tmp.pnt;
    bio.sysin.nam:=SYS_FIL_SPC(1);
    OPEN(bio.sysin,BLANKS(inptlinelng));

    ---  Now when the system files are open,we can output error messages
    bio.obs_evt:=EVT_INI;
    act_lvl:=ACT_USR;
    if envir_GET_INTINFO(19)>0 then bio.trc:=true endif; status:=0;
    inline:=nostring; curid:=nostring; inpos:=0; inlim:=0;
    bio.logfile:=0; errstat:=0;
    nbreaks:=max_break;
    repeat nbreaks:=nbreaks-1; stmnt(nbreaks).paddr:=nowhere
    while nbreaks > 0 do endrepeat;
    interactive:=envir_GET_INTINFO(33) > 0;
    if status <> 0 then status:=0; interactive:=false endif;
    if bio.trc then TRC_BPRG endif;
    goto   bio.sl.lsc;  ---  Now we can go back to the user program.

BIOINR:  IERR("BIOINR");            ---  Pray you will never get here.
%hidden


 USR_STMTS:   ---  A Run-Time error has occurred in the user program or the
              ---  observation tool. Issue the appropriate diagnostics.
              ---  If the error occurred in the user program and the
              ---  observation tool is present, give control to it.
              bio.obs_evt:=EVT_ERR;
 SMB_STMTS:   -- Call SIMOB --
              act_lvl:=ACT_SMB; call PSIMOB(smb)(0,none,none);
              act_lvl:=ACT_USR;
              if (bio.erh.sl <> none) and RT_ERR
              then var((bio.ern.ins+bio.ern.fld) qua name(integer)) := er_no;
                   erh:=bio.erh; bio.erh.sl:=none; bio.ern.ins:=none;
                   E_GOTO(erh);
              else goto curins.lsc endif; --- Resume user program

 TRM_STMTS:   -- Control should come here if controlled
              -- termination is wanted after an error.
              act_lvl:=ACT_TRM; E_PROG(er_trm,nostring);

 SYS_STMTS:   -- Control should come here if immediate
              -- termination is wanted after an error.
              act_lvl:=ACT_TRM; envir_TERM(er_trm,nostring);
end;
