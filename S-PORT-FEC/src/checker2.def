External class CHECKER1;

CHECKER1 class CHECKER2;
%      -----------------------------------------------------------------------
%      ---                                                                 ---
%      ---  COPYRIGHT 1985,86 by                                           ---
%      ---  Simula a.s.                                                    ---
%      ---  Oslo, Norway                                                   ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---                 P O R T A B L E     S I M U L A                 ---
%      ---                                                                 ---
%      ---              F R O N T - E N D    C O M P I L E R               ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---      S e m a n t i c    C h e c k e r     P a r t  2.           ---
%      ---                                                                 ---
%      --- Selection switches: DIZ                                         ---
%      ---                                                                 ---
%      ---    'D' Included when dump is wanted                             ---
%      ---    'I' Included to make compiler use inserted mnemonics         ---
%      ---    'K' Included always when quick capability wanted             ---
%      ---    'P' Included to make compiler use quick procedures           ---
%      ---    'Z' Included at system generation (for "ZIMULA")             ---
%      ---                                                                 ---
%      -----------------------------------------------------------------------
begin

%+I %INSERT (FEC-105)COMMON:MNE
%+I %INSERT (FEC-105)SCOPE:MNE

ref(semchecker) checker;

semchecker1 class semchecker;
begin

 !TEMP;      boolean TEMP_CHECK_flag;  !text conc not impl message given;

      ref(unstack)ust;
      boolean array recunstackstop(0:150);  ! zero never used;
      ! the symbols which should stop unstacking in case of
        abnormal termination of expressions;

      boolean priorpresent;
      short integer REAC;

      ref(switchdef) curswitch;
      ref(switchelement) curswitchel;
%title ******   activateprelude   ******

      ref(quantity)   c_activ_formal;
      ref(parameter)  c_activ_param;
      ref(pre_argumented)   activ_argumented;

%+P   prior
      procedure activateprelude(reac,no,code); short integer reac,no,code;
      begin  ! reac is either IACTV or IREAC
               no   is one of 1,2 or 3
               code is one of IBEFO,IAFTR,IDELA,IAT  ;
         ref(identifier) activ_ident;

         globmeaning(if no=1 then actindex1 else
                     if no=2 then actindex2 else actindex3 );
         activquant:-gm_result;
         if rank(activquant.categ)=INEW then errLT(454) else begin
            c_activ_formal:-activquant.descr.fpar;
            c_activ_param:- new parameter(1,exptop,c_activ_formal);
            activ_ident:- new identifier(exptop,IIDNP,
                                         if no=1 then actindex1 else
                                         if no=2 then actindex2
                                         else actindex3,
                                         none );
            exptop:-activ_ident.pred; activ_ident.pred:-none; !pop off stack;
            activ_argumented:- new pre_argumented(none,IARGE,activ_ident,
                                                  c_activ_param, 0,0 );
            processquant:-  activquant.descr.fpar.prefqual;
         end;

            ! Type and qual check for the first ref(process)-parameter,
              i.e. the expression following '(re)activate' ;
            ! 'exptop' refers to this expression ;
         if exptop.type <> IOTHW then begin
            if exptop.type <> IREF then errLT(456)
            else begin
              if exptop.qual=/=processquant then begin
                if not subclass( exptop.qual, processquant) then begin
                  if subclass( processquant, exptop.qual) then begin
                     c_activ_param.implqua:=true; !generate QuaCheck;
                  end else errLNT(qlin(exptop.qual),457);
                end;
              end;
            end;
         end type and qual check;

            ! generate the parameters for reactivate/activate
              and for before/after  or at/delay               ;
         c_activ_formal:- c_activ_formal.next;
         c_activ_param:-
         c_activ_param.nextarg:-
            new parameter(2,if reac=IACTV then false_const else true_const,
                          c_activ_formal);
         if no<3 then begin
            c_activ_formal:- c_activ_formal.next;
            c_activ_param:-
            c_activ_param.nextarg:-
               new parameter(3,if code=IBEFO or code=IAT
                               then false_const else true_const,
                             c_activ_formal);
         end;

      end activateprelude;
%title ***   Constant Element Evaluation   ***

      ref(ConstEltChecker) constantelt;

%  In addition, code will be issued for an appropriate assignment, if the
%  identifier is a class attribute. This is done to take care of dot access
%  and inspect in a proper manner (side effects of the dot expr/inspect new).
%  Note that the attribute is marked constant so that it will normally be
%  replaced by the expression value, e.g. in the class body;

      class ConstEltChecker;
      begin ref(quantity) meaning;     ! meaning of identifier declared;
%           ref(quant) cq;             ! quant of same;
            short integer type;        ! type of same;
%           ref(brec) cbrec;           ! - of enclosing block;
            ref(preident)id;           ! used if assign code must be emitted;
            short integer index;       ! index of identifier (=opd at call 1);

            id:-new preident(none,ISIDN,0);

       REP:   detach;
            ! *******  => wait until '=' in const elt is rec'ved;

            index:=opd; globmeaning(index);  meaning:-gm_result;
%           cbrec:-bltab(meaning.encl.blno);
%           cq:-cbrec.fpar; !search attr. list of encloser for identifier;
%           while cq.ident<>index do cq:-cq.next; !Note: always found!!!;
            type:=rank(meaning.type);

              detach;
            ! *******  => wait until expression is on top of stack;

%           if cq.extname<>-index or not (exptop in const) then begin
            if meaning.arraylb<>index or not (exptop in const) then begin
               ! double definition of constant - give error mess.;
               errLT(412); goto EXIT end;
%           if rank(cbrec.kind)=ICLAS then begin
            if rank(meaning.encl.kind)=ICLAS then begin
               ! re-use 'id', set attributes;
               id.index:=index;  id.meaning:-meaning;
               id.kind:=rank(meaning.kind); id.type:=type;
               id.qual:-if type=ITEXT then textclass else meaning.prefqual;
               !identifier in id ("above top"), expr in exptop;
               if type=ITEXT or!else; type=IREF
               then new refassign(none,type,id,exptop).emit
               else new valassign(none,type,id,exptop).emit;
            end assignment;
%           meaning.arraylb:=cq.extname:= exptop.getindex(type);
            meaning.arraylb:= exptop.getindex(type);
      EXIT: exptop:-exptop.pred; !pop off const expr ;
            goto REP;
      end ConstEltChecker;
%title ***  C l a s s   U n s t a c k  ***

      class unstack;
      begin integer   lhi, rhi;  !*** these variables are used;
            text      lht, rht;  !    during constant folding ;
            boolean   lhb, rhb;
%+R         long real lhs, rhs;
%-R         integer   lhs, rhs;

            character array priority,comprior(0:150);
           ! priorities and comparative priorities of operators;

%+P         prior
            procedure ReplaceByConst(type,val);
            !*** replace sos and exptop by "val";
            short integer type; !wanted type;
%+R         long real val;      !const value;
%-R         integer   val;
            begin short integer index; text valt;
%+R               if type=IINTG then begin
                     valt:-leftint(val);
%+R               end else begin
%+R                  valt:-leftreal(val) end
                  ;
                  DEFCONST(valt);
                  exptop:- new arithconst(sos.pred,ICONS,HASHINDEX,type);
            end;

            switch action :=
%INSERT (FEC-105)SWITCH:INIT

       while true do begin
            detach;          ! ****  only detach in this module  *** ;

%+D         if Soption then
%+D         begin outimage; outtext("unstack, insymbol= ");
%+D               outtext(DB(opn)); outtext(" comprior= ");
%+D               outint(rank(comprior(opn)),5); outimage;
%+D         end;

            while priority(rank(optstack(opttop)))>=comprior(opn) do
            begin if exptop==none
                  then internalerror(567) !exptop==none at unstack;
                  else sos:-exptop.pred;
                  copt:=rank(optstack(opttop));

%+D               if Soption then
%+D               begin outtext("unstack  ");
%+D                     outtext(DB(copt)); outtext("   prior= ");
%+D                     outint(rank(priority(copt)),5); outimage;
%+D                     outtext("second of stack:");outimage;
%+D                     if sos=/=none then sos.dump;
%+D                     outtext("top of stack:");outimage;
%+D                     if exptop=/=none then exptop.dump;
%+D               end;

                  goto action(copt);


         LIELSE:  ! else in conditional expression;
         LIEEXP:  ! end of conditional expression;
                  inspect sos.pred do
                  if ctype=char(IBOOL) then begin
                     if this exp qua boolconst.constvalue
                     then exptop:-sos;
                     exptop.pred:-pred
                  end else
                     exptop:-new ifexp(pred,IELSE,sos,exptop,this exp);
                  goto popoperator ;

         LIPLUS:
         LIMINU:
         LIMULT:
                  ltype:=sos.type;  rtype:=exptop.type;
                  lhi:= if ltype=ILONG or!else; rtype=ILONG then ILONG else
                        if ltype=IREAL or!else; rtype=IREAL then IREAL
                        else IINTG;
                  if sos.ctype=char(ISHOR) and!then; exptop.ctype=char(ISHOR)
                  then begin
                     lhs:=   sos qua arithconst.constvalue;
                     rhs:=exptop qua arithconst.constvalue;
                     ReplaceByConst(lhi,     if copt=IPLUS then lhs+rhs
                                        else if copt=IMINU then lhs-rhs
                                             else lhs*rhs);
                  end
                  else begin
                     exptop:-new arithop(sos.pred,copt,sos,exptop);
                     exptop.type:=lhi;
                  end;
                  goto popoperator;

         LIUMNS:  if exptop.ctype=char(ISHOR) then begin !invert sign;
                     lht:-idname(exptop qua const.index); lht.setpos(1);
                     lht:- if lht.getchar='-' then lht.sub(2,lht.length-1)
                           else conc("-",lht);
                     DEFCONST(lht); exptop qua const.index:=HASHINDEX;
                  end
                  else exptop:-new unary(sos,IUMNS,none,exptop);
                  goto popoperator;

         LIIDIV:
                  if sos.ctype=char(ISHOR) and!then; exptop.ctype=char(ISHOR)
                     and!then; sos.type=IINTG and!then; exptop.type=IINTG
                  then begin
                     lhi:=   sos qua arithconst.constvalue;
                     rhi:=exptop qua arithconst.constvalue;
                     if rhi=0 then begin errLT(700); !division by zero;
                        rhi:=1 end;
                     ReplaceByConst(IINTG,lhi//rhi)
                  end
                  else exptop:-new integerdivide(sos.pred,IIDIV,sos,exptop);
                  goto popoperator;

         LISLAS:
                  if sos.ctype=char(ISHOR) and!then; exptop.ctype=char(ISHOR)
                  then begin
                     lhs:=   sos qua arithconst.constvalue;
                     rhs:=exptop qua arithconst.constvalue;
                     if rhs=0 then begin errLT(700); !division by zero;
                        rhs:=1.0 end;
                     ReplaceByConst(if sos.type=ILONG or!else; exptop.type=ILONG
                                    then ILONG else IREAL,lhs/rhs)
                  end
                  else exptop:-new divide(sos.pred,ISLAS,sos,exptop);
                  goto popoperator;

         LIPOWE:
                  if sos.ctype=char(ISHOR) and!then; exptop.ctype=char(ISHOR)
                  then begin
                     lhs:= sos qua arithconst.constvalue;
                     rhs:=exptop qua arithconst.constvalue;
                     if exptop.type=IINTG then begin  rhi:=rhs;
                        if sos.type=IINTG then begin  lhi:=lhs;
                           if rhi<0 or!else; (lhi=0 and!then; rhi=0) then begin
                              errLT(700); !power undef; rhi:=1 end;
                           ReplaceByConst(IINTG,lhi**rhi) end
                        else begin
                           if rhi=0 and!then; lhs=0.0 then begin
                              errLT(700); !power undef; rhi:=1 end;
                           ReplaceByConst(if sos.type=ILONG
                                             or!else; exptop.type=ILONG
                                          then ILONG else IREAL,lhs**rhi)
                        end
                     end
                     else begin
                        if lhs<0 or!else; (lhs=0 and!then; rhs<=0) then begin
                           errLT(700); !power undef; rhs:=1.0 end;
                           ReplaceByConst(if sos.type=ILONG
                                             or!else; exptop.type=ILONG
                                          then ILONG else IREAL,lhs**rhs)
                     end
                  end
                  else exptop:-new power(sos.pred,IPOWE,sos,exptop);
                  goto popoperator;

         LIEQ:LINE: !check for comp. w/notext;
                  if (if sos.ctype<>char(ITEXT) then false else
                         sos qua textconst.constvalue==notext)  or!else;
                     (if exptop.ctype<>char(ITEXT) then false else
                         exptop qua textconst.constvalue==notext)
                  then begin
                     !*** replace value relation by reference relation ***;
                     copt:=if copt=IEQ then IRFEQ else IRFNE; goto LIRFNE end;
                  !no goto here;

         LIGE:LIGT:LILE:LILT:  ! value comparators;
                  if sos.ctype=char(ISHOR) and!then; exptop.ctype=char(ISHOR)
                  then begin
                     lhs:=sos qua arithconst.constvalue;
                     rhs:=exptop qua arithconst.constvalue;
              SETX:  lhi:= if (copt=IEQ and!then; lhs =rhs) or!else;
                              (copt=INE and!then; lhs<>rhs) or!else;
                              (copt=ILE and!then; lhs<=rhs) or!else;
                              (copt=IGE and!then; lhs>=rhs) or!else;
                              (copt=ILT and!then; lhs <rhs) or!else;
                              (copt=IGT and!then; lhs >rhs)
                           then ITRUE else IFALS;
              CONX:  exptop:-new boolconst(sos.pred,ICONS,lhi);
                  end

             else if sos.ctype=char(ITEXT) and!then; exptop.ctype=char(ITEXT)
                  then begin
                     lht:-   sos qua textconst.constvalue;
                     rht:-exptop qua textconst.constvalue;
                     lhi:= if (copt=IEQ and!then; lht =rht) or!else;
                              (copt=INE and!then; lht<>rht) or!else;
                              (copt=ILE and!then; lht<=rht) or!else;
                              (copt=IGE and!then; lht>=rht) or!else;
                              (copt=ILT and!then; lht <rht) or!else;
                              (copt=IGT and!then; lht >rht)
                           then ITRUE else IFALS; goto CONX
                  end

             else if sos.ctype=char(ICHAR) and!then; exptop.ctype=char(ICHAR)
                  then begin
                     lhs:=   sos qua charconst.index;
                     rhs:=exptop qua charconst.index;
                     goto SETX;
                  end

                  else exptop:-new valuerel(sos.pred,copt,sos,exptop);
                  goto popoperator ;

         LICAND:  ! conditional (boolean) and-then;
         LICOR:   ! conditional (boolean) or-else;
         LIAND:LIEQV:LIIMP:LIOR:  ! boolean operators;
         LINOT:   ! unary not;
                  if copt=INOT then exptop:-
                     if exptop.ctype=char(IBOOL)
                     then new boolconst(sos,ICONS,
                       if exptop qua boolconst.constvalue then IFALS else ITRUE)
                     else new boolop(sos,copt,none,exptop)
             else if sos.ctype=char(IBOOL) then begin
                     lhb:=sos qua boolconst.constvalue;
                     if copt=(if lhb then ICOR else ICAND)
                     then exptop:-sos !no evaluation of exptop;
                else if exptop.ctype=char(IBOOL) then begin !use sos as result;
                        rhb:=exptop qua boolconst.constvalue;
                      exptop:-if ( (copt=IAND  and!then; (lhb and rhb)) or!else;
                                   (copt=IOR   and!then; (lhb  or rhb)) or!else;
                                   ((copt=ICAND or copt=ICOR)and rhb ) or!else;
                                   (copt=IEQV  and!then; (lhb eqv rhb)) or!else;
                                   (copt=IIMP  and!then; (lhb imp rhb))
                                 ) eqv lhb then sos
                              else new boolconst(sos.pred,ICONS,
                                                 if rhb then IFALS else ITRUE)
                     end  else goto GEN
                  end  else
            GEN:  exptop:-
                     if copt=ICOR or!else; copt=ICAND
                     then new expinparantes(sos.pred,IRGPA,
                          new ifexp(sos.pred,IELSE,
                              if copt=ICAND then exptop else true_const,
                              if copt=ICAND then false_const else exptop,sos
                          ),
                          none)
                     else new boolop(sos.pred,copt,sos,exptop);
                  goto popoperator;

         LIRFEQ:LIRFNE:  ! reference comparators ==,=/=;
                  if sos.ctype=char(ITEXT) and!then; exptop.ctype=char(ITEXT)
                  then begin
                     rhi:=exptop qua textconst.index;
                     lhi:=   sos qua textconst.index;
                     exptop:-new boolconst(sos.pred,ICONS,
                                           if (copt=IRFEQ and lhi =rhi) or
                                              (copt=IRFNE and lhi<>rhi)
                                           then ITRUE else IFALS)
                  end

                  else  exptop:-new refrel(sos.pred,copt,sos,exptop);
                  goto popoperator;

         LICONC:  ! text concatenator ;
                  !*** not impl. - replace by first operand (sos) ***;
 !TEMP;           errLT(460); exptop:-sos; goto popoperator;

         LIABTE: ! abnormal termination of expression;
                 internalerror(568);
                 ! abnormal termination of expr in unstack;

         LIFASG:
                  exptop:-new valassign(sos,IFASG,
                                     sos qua forlist.cvar,exptop);
                  goto REPEAT;

         LIFDNO:
                  exptop:-new refassign(sos,IFDNO,
                                      sos qua forlist.cvar,exptop);
                  goto REPEAT;

         LIASSG:  ! := ;
                  exptop:-new valassign(sos.pred,IASSG,sos,exptop);
                  goto popoperator ;

         LIDENO:  ! :- ;
                  exptop:-new refassign(sos.pred,IDENO,sos,exptop);
                  goto popoperator ;

         LITO:    ! constant elt - evaluation;
                  call(constantelt);  goto popoperator;

         LINEW: LINEWP: LICL: LIDCLI: LIDCLE: LIDCLS: LISWEE: LISWDE:
         LIDCLA: LIBNDE:LIDIME:LIARDE: LIDCLP: LIBLKB:
         LIFRMP:LIPSPC:LIEPRM:LICPRF:LIVALU:LICSPC:
         LIHIDD:LIPRTC:LIPRHI:LIVSPC:LINOTY:LIPROC:
         LIDCLC: LIECWI: LIEND: LIEXTR: LIEXNM: LISIMU: LILANG:
         LISIDN:LIIDN: LIIDNP: LIDOT: LIDOTP: LISCST: LICONS: LIIF:
         LILFPA: LIRGPA: LIIN:LIIS: LIQUA: LITHIS: LITHEN:
         LIIFSB:LIGOTO:LIWSTB: LIINSP: LITHSB:LIWHDO:LIGOE:
         LIELSB: LIIFSE: LIWHSE: LIASGE: LICOMA:
         LIARGE:LICAPE:LIBEGI: LIBPRF: LIESTM: LICONB:LIFWHN:
         LIWHEN: LIOTHW: LICONE: LIOTHE: LIINNE: LIFOR: LIWHIL:
         LISTEP: LIUNTI: LIDO: LIELME: LIFORE: LIACTV:LIREAC:
         LIBEFO:LIAFTR:LIAT:LIDELA: LIPRIO: LIACTE: LIBLNO: LIEOP:
         LIBOOL:LICLAS:LICHAR:LIINTG:LILABE:LILONG:LINAME:
         LIREAL:LIREF:LISHOR:LITEXT:LIVIRT:LISSWA:LISSWB:
         LIARRA:LIGO:     LICOMN:LINOTE:LISWIT:LITRUE:
         LILINE:LINONE:LIFALS: LIROPD:LIBREC:LIEREC:LISMCL:LIUPLS:
                  internalerror(569); !wrong operator to unstack ;

     popoperator: ! pop the top operator from operatorstack;
                  opttop:=opttop-1;
%+D               if Soption then
%+D               begin outimage; outtext("result=   ");outimage;
%+D                     if exptop=/=none then exptop.dump; outimage;
%+D               end;
            end while;
REPEAT:
       end unstack loop;
      end unstack;
%title ***  S e m c h e c k e r  -  M a i n   P a r t  ***

      detach;    !*** perform initialisations ***;

   inspect L2INPT do begin
      boolean checkclb;       ! check 1-dim. array decl for const lower bound;
      switch action:=
%INSERT (FEC-105)SWITCH:INIT

     goto start;

LIIF:                         ! if in conditional expression;
LILFPA:                       ! left paranthesis "(" ;
LIFASG:LIFDNO:LIASSG:LIDENO:  ! :=/:- ;

stack:                        ! stack the current input symbol;
       opttop:=opttop+1; optstack(opttop):=char(opn);
       expexptop(opttop):-exptop; goto start;

LIINSP:
LIELSB:                       ! else in if-statement ;
LIIFSE: LIWHSE:               ! end of if-stmt/end of while-stmt;
LIOTHE:                       ! end of inspect in case of otherwise present;

opnout:     opc:=opn;         ! delivers the current input symbol to coder;

callcoder:  call(coder);
%+D         goto start;

% The following symbols are dummy - should never be received from Pass1;
LIDCLI: LIEXTR: LIEXNM: LISIMU: LILANG:  ! external declarations;
LIFRMP:LIPSPC:LIEPRM:LICPRF:LIVALU:LICSPC:
LIHIDD:LIPRTC:LIPRHI:LIVSPC:LINOTY:LIPROC:
LIBOOL:LICLAS:LICHAR:LIINTG:LILABE:LILONG:LINAME:
LIREAL:LIREF:LISHOR:LITEXT:LIVIRT:
LIARRA:     LICOMN:LINOTE:LISWIT:LITRUE:
LINONE:LIFALS:LIROPD:LIBREC:LIEREC:LIUPLS:

%+D    if parserdump then begin
%+D       outtext("DUMMY to Pass2: "); outtext(DB(opn)); outimage end;

start:

%+D    if Soption then
%+D    begin if Toption then
%+D          begin ref(exp)expv; short integer i;
%+D                outtext("  exp-stack:");outimage;
%+D                for expv:-exptop,expv.pred while expv=/=none do expv.dump;
%+D                outtext("operator-stack:");outimage;
%+D                for i:=opttop step -1 until 0 do
%+D                begin outtext(DB(rank(optstack(i)))); outimage end;
%+D          end;
%+D    end;

       opn:=inbyte;

%+D    if Roption or Soption then
%+D    begin outimage; outtext("opn: "); outtext(DB(opn)); outint(opn,4) end;

       goto action(opn);
%title ***  Declarations  ***
LICL:  ! label declaration;
         opc:=IDCLA;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         globmeaning(opd);
         opq:-gm_result;
         if rank(opq.categ)=IVIRT and opq.match=/=none then opq:-opq.match;
         goto callcoder;

LIDCLE:  ! declaration end;
         opq:-display(cblev).declquant; goto opnout;

LIDCLS:  ! switch declaration begin;
         opttop:=opttop+1; optstack(opttop):=char(opn);
         expexptop(opttop):-exptop;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         exptop:-curswitch:-new switchdef(exptop,INOTY,opd);
         curswitch.elements:-curswitchel:-new switchelement(none);
         !dummy first element; goto start;

LISWEE:  ! switch element comma;
         call(ust); curswitchel:-curswitchel.next:-new switchelement(exptop);
         exptop:-exptop.pred; goto start;

LISWDE:  ! switch declaration end;
         curswitch.elements:-curswitch.elements.next; !removing dummy ;
         curswitch.checkplainswitch;
         !L3 exp output; exptop.emit;
         exptop:-exptop.pred; opttop:=opttop-1;
         goto start;

LIDCLA:  ! array declaration begin;
         inarraybound:=true;  arrbno:=0;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         globmeaning(opd);
         q:-opq:-gm_result;
         checkclb:=opq.dim=1; !check for poss. const. lower bound;
         if opq.dim > 10 then errLNT(qlin(opq),461); !'maxdim' fixed in RTS;
         goto opnout;

LIBNDE:  if checkclb then begin checkclb:=false;
            call(ust);
            if exptop is arithconst and inarraybound then begin
               !set constant lower bound - q:-array quantity;
               short integer resx;
               resx:=exptop.getindex(IINTG);
               if resx<>0 then begin
                  q.arraycateg:='!1!'; q.arraylb:=resx end;
            end;
            goto BNDE1
         end; ! no goto here;

LIDIME:LIARDE:  ! array bound pair colon/comma/end;
         call(ust);
 BNDE1:  arrbno:=arrbno+1;
         if exptop.type <> IOTHW then
         begin if rank(nearly(exptop.type)) <> IINTG then
               begin tar.sub(20,2).putint(arrbno);
                     GiveMessage(q.line,2,cat(qat(q.ident,416),tar));
               end;
         end;
         if exptop is identifier then exptop qua identifier.checkasexp;
         exptop.cl:=IEEXP;
         !L3 exp output; exptop.emit;
         if exptop.type <> IINTG then MaybeConvert(IINTG,exptop.type);
         if exptop.pred=/=none then exptop:-exptop.pred;
         if opn=IARDE then inarraybound:=false;
         goto opnout;

LIDCLP: LIBLKB:  ! procedure declaration/block begin;
         build_scope(lastblno);
         opc:=IBLKB; opq:-blocktab.elt(lastblno).declquant;
         call(coder); enter_block(lastblno);
         formals(cblev):-new formal(actindex1,IEEXP,none,none);
         goto start;

LIDCLC:  ! class declaration;
         opc:=IBLKB; opq:-blocktab.elt(lastblno).declquant;
         call(coder); enter_block(lastblno);
         formals(cblev):-new formal(actindex1,IEEXP,none,none);
         goto start;

LIECWI: ! end class body without inner;
LIEND:  ! block end;

         if separatecomp then
         begin if cblev = 2 !=sepcomplev+1; then
               begin if numerrfound=0 then

%        ! Produce attribute file in case of separate compilation  ;
%        ! and pass2 or passB ;
%        ! The production is placed here in order to have it performed ;
%        ! before activation of the coder, which in the 2 pass version ;
%        ! will destroy the value of quantity.dim (is set to -1 to     ;
%        ! indicate that descriptors are output).                      ;
%        ! Still valid ???? ;

                     begin ref(quantity)main;
                           main:-display(2!sepcomplev+1;).declquant;
                           if rank(main.kind)=IPROC then main:-main.prefqual;
                           sepcompilation(display(1!sepcomplev;).fpar,
                                    main,checkcode,moduleident);
                     end;
               end;
         end;
         opq:-display(cblev).declquant; opc:=opn; call(coder);
         leave_block; goto start;

%title ***  Expression Operators  ***
LITO:    ! start of constant decl;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         call(constantelt); goto stack;

LISMCL:  ! end of constant decl;
         call(ust); goto start;

LISIDN:  ! single identifier;
LIIDN:   ! identifier;
LINEW:   ! new - object generator;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         new identifier(exptop,opn,opd,none);
         goto start;

LIIDNP:  ! identifier with arguments;
LINEWP:  ! new - object generator with parameters;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         new identifier(exptop,opn,opd,none);
         lastnap:-new nextargumentproducer(lastnap,exptop);
         call(lastnap);
         opttop:=opttop+1; optstack(opttop):=char(IFRMP);
         expexptop(opttop):-exptop; goto start;

LIDOT:  ! remote identifier;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         new identifier(exptop.pred,opn,opd,exptop);
         goto start;

LIDOTP: ! remote identifier with arguments;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         new identifier(exptop.pred,opn,opd,exptop);
         lastnap:-new nextargumentproducer(lastnap,exptop);
         call(lastnap);
         opttop:=opttop+1; optstack(opttop):=char(IFRMP);
         expexptop(opttop):-exptop; goto start;

LISCST:  ! single constant;
LICONS:  ! constant;
         optx:=inbyte; opd:=in2byte;
%+D      if Roption then begin
%+D         outtext(", optx,opd: "); outtext(DB(optx)); outint(opd,7) end;
         NewConstant(exptop,opn,opd,optx);
         goto start;

LIRGPA:  ! right paranthesis ")" ;
         call(ust);
         exptop:-new expinparantes(exptop.pred,IRGPA,exptop,none);
         opttop:=opttop-1; goto start;

LIIN:LIIS:  ! in/is - class comparators;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         exptop:-new classcomparator(exptop.pred,opn,exptop,none,opd);
         goto start;

LIQUA:  ! qua - instantanous qualification;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         exptop:-new instqual(exptop.pred,IQUA,exptop,none,opd);
         goto start;

LITHIS:  ! this - local object;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         exptop:-new localobject(exptop,ITHIS,none,none,opd);
         goto start;

LITHEN:  ! then in conditional expression;
         call(ust);
         optstack(opttop):=char(ITHEN); ! IIF replaced by ITHEN;
         expexptop(opttop):-exptop; goto start;

LIELSE:  ! else in conditonal expression;
         call(ust);
         optstack(opttop):=char(IELSE); ! ITHEN replaced by IELSE;
         expexptop(opttop):-exptop; goto start;

LIEEXP:  ! end of conditional expression;
         call(ust); goto start;

LIPLUS:LIMINU:LISLAS:LIMULT:LIIDIV:LIPOWE: ! arithmetic operators;
LIEQ:LINE:LIGE:LIGT:LILE:LILT:             ! value comparators;
LICAND:LICOR:LIAND:LIEQV:LIIMP:LIOR:       ! boolean operators;
LIRFEQ:LIRFNE:                             ! reference comparators ==,=/=;
LIUMNS:LINOT:                              ! unary operators;
LICONC:  ! text concatenation ;
         call(ust); goto stack;

LIABTE:  ! abnormal termination of expression;
         while not recunstackstop(rank(optstack(opttop)))  do
          opttop:=opttop-1;

         exptop:-expexptop(opttop); c:=rank(optstack(opttop));
         if c=IFRMP then
         begin !*** generate a dummy actual parameter expression;
               exptop:-new exp(exptop,IOTHW); exptop.type:=IOTHW end
    else if c <> INOTY then
         begin !*** generate a dummy expression;
               exptop:-new exp(exptop,IOTHW); exptop.type:=IOTHW;
         end;
         goto start;
%title ***  Statement symbols  ***
LIIFSB:LIGOTO:LIWSTB: ! start-of-statement symbols;
         opc:=opn; call(coder); goto stack;

LITHSB:LIWHDO:LIGOE:  ! then in if-stmt/do in while-stmt/
                              end of goto-stmt;
         call(ust);
         if exptop.type <> IOTHW and exptop.type <> rank(expectedtype(opn)) then
            errLT(if opn=IGOE then 462 else 463);
         if exptop is identifier then exptop qua identifier.checkasexp;
         exptop.cl:=if exptop is valuerel or exptop is refrel then
                    IIFSB else IEEXP;
         !L3 exp output; exptop.emit;
         opttop:=opttop-1; exptop:-exptop.pred;
         goto opnout;

LIASGE:  ! end of assignment statement;
         call(ust);
         !L3 exp output; exptop.emit;
         ! a whole multiple assignment is treated by unstack;
         if exptop.pred=/=none then exptop:-exptop.pred;
         goto opnout;

LICOMA:  ! comma between argument expressions;
         call(ust); ! getting the actual exp as exptop;
         call(lastnap); ! generates next argument;
         goto start;

LIARGE:LICAPE:LIBEGI:  ! end of argument list;
         call(ust);
         call(lastnap); ! generates next argument;
         lastnap.inuse:=false;
         call(lastnap); ! brings lastnap back to be used again;
            ! exptop denotes the identifier of the call;
         exptop:-new argumented(exptop.pred,
                                if opn=IBEGI then IBPRF else IARGE,
                                exptop,
                                lastnap.firstarg,
                                lastnap.noofexpargs,
                                lastnap.argno);
         lastnap:-lastnap.pred;
         argerrtop:=argerrtop-1;
         !L3 exp output;
         if opn=IBEGI then begin exptop.emit;exptop:-exptop.pred end;
         opttop:=opttop-1; ! removes IFRMP from stack;
         goto start;

LIBPRF:  ! prefixed block without parameters;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         new identifier(exptop,opn,opd,none);
         !L3 exp output;
         exptop.emit; exptop:-exptop.pred; goto start;

LIESTM:  ! end of statement;
         inspect exptop
            when identifier do begin
                 if kind=IOTHW then !no testing; else
                 if kind=IPROC then begin
                    checkasexp;
                    if rank(meaning.categ)=INEW then !nothing; else
                    if rank(meaning.categ) <> IDCLI then begin
                       if rank(meaning.categ) <> IEXTR
                            ! virtual or formal procedure call;
                       then recordactualuse(meaning,0);
                    end;
                 end else
                 if kind=ICLAS  then checkasexp else
                 if kind=IARRA then errLNT(qlin(meaning),464) else
                 if kind=ISWIT then errLNT(qlin(meaning),465) else
                 if kind=IIDN then errLNT(qlin(meaning),466) else
                 if kind=ILABE then errLNT(qlin(meaning),467)
                 else StopScode_1(570); !illegal kind at IESTM;   end
            when argumented do begin
                 vkind:=ident.kind;
                 if vkind=IOTHW then !no testing;
            else if vkind=IPROC then ! ok ;
            else if vkind=ICLAS then begin
                    if ident.ch=IIDNP then errLTN(470,qlin(ident.meaning));
                       ! For a legal class generator with parameters, ch
                        will be INEWP ;
                       ! This test is for class id with arguments in the case
                         opttop=0: Could possibly be a block prefix. The test
                         in class identifier is for all other cases ;
                 end
            else if vkind=IARRA then errLNT(qlin(ident.meaning),468)
            else if vkind=ISWIT then errLNT(qlin(ident.meaning),469)
                 else StopScode_1(571); !illegal argumented.kind at IESTM;
            end
            otherwise errLT(471);
         !L3 exp output; exptop.cl:=IEEXP; exptop.emit;
         exptop:-exptop.pred; goto opnout;

LICONB:LIFWHN:  ! do/first when in inspect-statement;
         call(ust);
         if exptop.type <> IOTHW and
            exptop.type <> IREF then errLT(472);
         if exptop is identifier then exptop qua identifier.checkasexp;
         exptop.cl:=IEEXP;
         !L3 exp output; exptop.emit;
         if opn=ICONB then begin
            enter_conn(exptop.qual);
            build_scope(lastblno);
            enter_stmt(lastblno);
            opq:-display(cblev).declquant.prefqual;  opc:=ICONB;
            goto callcoder;
         end;  ! no goto start here;

LIWHEN:
         if opn=IWHEN then begin leave_stmt; leave_block end;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         globmeaning(opd); cquant:-gm_result;
         if rank(cquant.categ) <> INEW and rank(cquant.kind) <> ICLAS then
         begin errLTNT(473,idname(opd),474); enter_conn(none) end
    else begin if exptop.qual=/=none then
               begin if not ( subclass(exptop.qual,cquant) or
                              subclass(cquant,exptop.qual) )
                     then noteLTNT(475,idname(opd),476);
               end;
               enter_conn(if rank(cquant.kind)=ICLAS then cquant else none);
         end;
         build_scope(lastblno); enter_stmt(lastblno);
         opq:-display(cblev).declquant.prefqual;
         opc:=opn; call(coder); goto start;

LIOTHW:  ! otherwise in inspect-statement;
LICONE:  ! end of inspect-statement in case of no otherwise;
         leave_stmt; leave_block;
         exptop:-exptop.pred; goto opnout;

LIINNE:  ! inner statement;
         opq:-display(cblev).declquant; goto opnout;

LIFOR:  ! for-statement;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         lastforelem:-new forelement(none);
         exptop:-new forlist(exptop,IFOR,opd,lastforelem);
         build_scope(lastblno);
         opq:-blocktab.elt(lastblno).declquant;
         goto opnout;

LIWHIL:  ! while in for-element;
LISTEP:  ! step in for-element;
         call(ust); ! a forassign expression is now on top of stack;
         goto stack;

LIUNTI:  ! until in for-element;
         call(ust); ! a step expression is now on top of the stack;
         optstack(opttop):=char(IUNTI);
         expexptop(opttop):-exptop; goto start;

LIDO:   ! do in for-statement;
LIELME:  ! comma between for-elements;
         call(ust);
         if rank(optstack(opttop))=IUNTI then
         begin ! generate a stepuntilforelement;
               lastforelem:-lastforelem.nextforelem:-
                 new stepuntilforelem(exptop.pred.pred, exptop.pred, exptop);
               opttop:=opttop-1;  ! unstacks IUNTI;
               exptop:-exptop.pred.pred.pred;
         end else
         if rank(optstack(opttop))=IWHIL then
         begin ! generate a whileforelement;
               lastforelem:-lastforelem.nextforelem:-
                 new whileforelem(exptop.pred, exptop);
               opttop:=opttop-1;  ! unstacks IWHIL;
               exptop:-exptop.pred.pred;
         end else
         begin ! generate a simple forelement;
               lastforelem:-lastforelem.nextforelem:- new forelement(exptop);
               exptop:-exptop.pred;
         end;

         if opn=IDO then
         begin opttop:=opttop-1;  ! unstacks IFASG/IFDNO from optstack;
               ! exptop denotes forlist expression;
               inspect exptop qua forlist do
               begin ! remove the first dummy forelement:  ;
                     forelements:-forelements.nextforelem;
                     !L3->forlist expression;
                     !L3 exp output;
                     emit; enter_stmt(lastblno);
                     !L3-> FOR-DO(-FAST) ;
                     opc:=if fast then IVSPC else IDO;
                     goto callcoder;
               end;
         end;
         goto start;

LIFORE: ! end of for-statement;
         leave_stmt;
         inspect exptop when forlist do
            opc := if fast then ICPRF  !L3-> END-FOR-FAST;
                           else IFORE; !L3->END-FOR;
         call(coder);
         exptop:-exptop.pred;     ! unstacking forlist element ;
         goto start;


LIACTV:LIREAC: ! activate/reactivate;
         REAC:=opn;     ! REAC changed type to character ;
         goto stack;


LIBEFO:LIAFTR:LIAT:LIDELA: ! before/after/at/delay;
         call(ust);
         if exptop is identifier then exptop qua identifier.checkasexp;
             ! Checks whether indices or parameters are missing ;
         exptop.cl:=IEEXP;
%        if opn=IBEFO or opn=IAFTR then activateprelude(REAC,1,opn) else
         activateprelude(REAC,if opn=IBEFO or opn=IAFTR then 1 else 2,opn);
         exptop:-exptop.pred;
         optstack(opttop):=char(opn); ! replace IACTV/IREAC with opn;
         expexptop(opttop):-exptop; goto start;


LIPRIO:  ! prior;
         call(ust);
         if exptop is identifier then exptop qua identifier.checkasexp;
         exptop.cl:=IEEXP; priorpresent:=true; goto start;

LIACTE:  ! end of activation-statement;
         call(ust);
         if exptop is identifier then exptop qua identifier.checkasexp;
         if rank(optstack(opttop))=IREAC or rank(optstack(opttop))=IACTV then
         begin exptop.cl:=IEEXP;
               activateprelude(REAC,3,opn);
               exptop:-exptop.pred;
         end
    else if rank(optstack(opttop))=IAT or rank(optstack(opttop))=IDELA then
         begin if exptop.type <> IOTHW and
                  rank(nearly(exptop.type)) <> IINTG
               then errLTTT(477,rank(optstack(opttop)),-1);
               exptop.cl:=IEEXP;
               c_activ_formal:- c_activ_formal.next;
               c_activ_param:-
               c_activ_param.nextarg:-
                     new parameter(4,exptop,c_activ_formal);
               exptop:-exptop.pred;
               c_activ_formal:- c_activ_formal.next;
               c_activ_param:-
               c_activ_param.nextarg:-
                  new parameter(5,
                             if priorpresent then true_const
                                             else false_const,
                             c_activ_formal);
               priorpresent:=false
         end else
         begin ! before or after;
               exptop.cl:=IEEXP;
               c_activ_formal:- c_activ_formal.next;
               c_activ_param:-
               c_activ_param.nextarg:-
                  new parameter(4,exptop,c_activ_formal);
               exptop:-exptop.pred;
         end before or after;
         opttop:=opttop-1; activ_argumented.emit; goto start;



      ! sundry symbols
      ----------------;
LIBLNO:  ! block no. ;
         lastblno:=in2byte;
%+D      if Roption then begin outtext("= "); outint(lastblno,5) end;
         goto start;

LILINE:
         opd:=in2byte;   if
%+D                         Roption or
                         Loption then begin outtext(" / "); outint(opd,5) end;
         opc:=ILINE; linenr:=opi:=opd; goto callcoder;

LISSWA:  ssnuma:=in2byte; goto start;

LISSWB:  ! The first parameter to setswitch is in ssnuma;
         opc:=ISSWB; opi:=in2byte;
%        array bounds checking: ssnuma=256, opi=0/1 (off=0)  ;
%        none checking:         ssnuma=257, opi=0/1 (off=0)  ;
%         qua checking:         ssnuma=258, opi=0/1 (off=0)  ;
%        reuse proc. act. rec.: ssnuma=259, opi=0/1 (off=0)  ;
%        enable spec. features: ssnuma=260, opi=0/1 (off=0)  ;
%        unknown directives:    ssnuma=987, opi=symtab-index of dir. text;
         if ssnuma=256 then BoundCheck:= opi=1 else
         if ssnuma=257 then NoneCheck := opi=1 else
         if ssnuma=258 then QuaCheck  := opi=1 else
         if ssnuma=259 then ReuseProc := opi=1 else
         if ssnuma=260 then SportOK   := opi=1 else goto callcoder;
         goto start;

LIGO:    ! new options from %SETOPT ;
         opd:=in2byte;
%+D      if Roption then begin outtext(", opd: "); outtext(idname(opd)) end;
         feoptions:-copy(idname(opd)); setoptions;
         opc:=IGO; opi:=opd; goto callcoder;

LIEOP:   ! end of program;
         opc:=opn; call(coder); ENDCOMP;

       end inspect L2INPT
       otherwise ENDCOMP;
      end class semchecker;
end CHECKER2;
