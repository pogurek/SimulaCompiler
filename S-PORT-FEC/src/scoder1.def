External class SCODER0;

SCODER0 class SCODER1;
%      -----------------------------------------------------------------------
%      ---                                                                 ---
%      ---  COPYRIGHT 1985,86 by                                           ---
%      ---  Simula a.s.                                                    ---
%      ---  Oslo, Norway                                                   ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---                 P O R T A B L E     S I M U L A                 ---
%      ---                                                                 ---
%      ---              F R O N T - E N D    C O M P I L E R               ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---      S - C o d e    G e n e r a t o r     P a r t  1.           ---
%      ---                                                                 ---
%      --- Selection switches: DKPIZ                                       ---
%      ---                                                                 ---
%      ---    'D' Included when dump is wanted                             ---
%      ---    'K' Included always when quick capability wanted             ---
%      ---    'P' Included to make compiler use quick procedures           ---
%      ---    'I' Included to make compiler use inserted mnemonics         ---
%      ---    'Z' Included at system generation (for "ZIMULA")             ---
%      ---                                                                 ---
%      -----------------------------------------------------------------------
begin

%+I %INSERT (FEC-105)COMMON:MNE
%+I %INSERT (FEC-105)SCODER:MNE
%+I %INSERT (RTS-105)RTSINIT:MNE

      codegenerator0 class codegenerator1;
      begin
         short integer maxusedtag; ! The highest tag ever used;

         !********* S T A T U S  V A R I A B L E S   E.T.C. *********;

         integer waitingline; comment: Is nonzero and has linenumber
                              when lineshift occurred when asd>0;

         ! Used in coding of designational expressions:       ;
         boolean ingotostmt;        ! true between GOTO and END-GOTO ;
         boolean inswitchdecl;      ! true between DECL (with opq.kind=
                                      ISWIT) and SWITCH-END ;
         boolean generalgoto;       ! true when ingotostmt and
                                      general designational expression;
         boolean notinconditional;
            ! is significant between the following pairs of symbols:
              (GOTO, END-GOTO), (DECL, SWITCH-COMMA) and (SWITCH-COMMA,
              SWITCH-END).  Then it will be true if we are not inside
              a conditional designational expression ;

         ! Last portion from checker;
         short integer lastopc,lastopt,lastopi;

         comment: Work variables, very local use: ;
         short integer iii,jjj,xxx;

         short integer prototinfo;   ! Tag of modinfo, in prototypes;
               !*** set in SCODESTART, used by prototypegenerator ***;

         short integer thunklabel;
         ref(quantity)qty;


%title ****** the "assembly stack" with connected procedures ******

         short integer array asdstack(0:maxasd); !zero never used;
         short integer asd; ! top of asdstack - NOTE: asd<>0 => save/restore;
         short integer curasd;  !stack pointer;

%+P      prior
         procedure pushasd;
         ! Called from outbseg, outskipif, outif, expandsave;
         begin if curasd >= maxasd then StopScode_1(574) else !asd overflow;
               curasd:=curasd+1; asdstack(curasd):=asd;
         end;

%+P      prior
         procedure popasd;
         ! Called from outeseg, outendskip, outendif, expandrestore;
         begin asd:=asdstack(curasd); curasd:=curasd-1 end;

%+P      prior
         procedure exchasd;  ! Called from outelse ;
         begin short integer i; i:=asd;
               asd:=asdstack(curasd); asdstack(curasd):=i;
         end;

%+P      prior
         procedure checksavedstacks; ! Called from outdelete ;
         begin short integer i; i:=0;
               while i<curasd do begin i:=i+1;
                     if asdstack(i) <> 0 then asderror(478) end;
         end;

%+P      prior
         procedure asderror(n); short integer n;
         begin  if numerrfound=0 then errLTT(480,n);
                coder:-dumgen; termstatus:='5' end;

%-I %+P  prior
%-I      procedure checkasdzero;
%-I      ! Called from outeseg, outempty, outendskip, outlabeldef,
%-I        outgoto, outfjumipif, outfdest, outbdest, outbjump,
%-I        expandrestore ;
%-I      if asd <> 0 then asderror(481);

%-I %+P  prior
%-I      procedure checkasdequal;       ! called from outendif ;
%-I      if asd <> asdstack(curasd) then asderror(482);

%title ***  Utility Procedures ***

%+P      prior
         procedure notimp(t,i); text t; short integer i;
         begin errLTNT(479,cat(t,leftint(i)),-1);
               coder:-dumgen;
         end;

%title ***  The procedures producing single S-instructions  ***

%-I %+P  prior
%-I      procedure outinstr(n); short integer n; SCF.outbyte(n);

%+P      prior
         procedure outtag(t); short integer t;
               SCF.out2byte(if t<0 then dirtag(t) else t);

%+P      prior
         procedure outstring(s); short integer s;
         begin text t;
%+Z            t:-idname(s);
%-Z            t:-symtab(s//256).val(rem(s,256));
               SCF.outbyte(t.length);
%-Z            SCF.outtext(t);
%+Z            t.setpos(1); while t.more do SCF.outbyte(isorank(t.getchar));
         end;

%+P      prior
         procedure outlongstring(s); short integer s;
         begin text t;
%+Z            t:-idname(s);
%-Z            t:-symtab(s//256).val(rem(s,256));
               SCF.out2byte(t.length);
%-Z            SCF.outtext(t);
%+Z            t.setpos(1); while t.more do SCF.outbyte(isorank(t.getchar));
         end;

%+P      prior
         procedure outinteger(i); integer i;
         begin text t; ! Outputs a direct integer constant;
               SCF.outbyte(vcint); t:-leftint(i); SCF.outbyte(t.length);
%-Z            SCF.outtext(t);
%+Z            t.setpos(1); while t.more do SCF.outbyte(isorank(t.getchar));
         end;

%-I %+P  prior
%-I      procedure outattrdef(newtag,type); short integer newtag,type;
%-I      begin SCF.outbyte(vattr); outtag(newtag); outtag(type) end;

%-I %+P  prior
%-I      procedure outendrecord; SCF.outbyte(vendrecord);


         ! Procedures for a record constant:
          <outrecordconst> <<outattrconst><constvalue>>* <outendrecord>;

%-I %+P  prior
%-I      procedure outrecordconst(type); short integer type;
%-I      begin SCF.outbyte(vcrecord); outtag(type) end;

%-I %+P  prior
%-I      procedure outattrconst(attrtag,type); short integer attrtag,type;
%-I      begin SCF.outbyte(vattr); outtag(attrtag); outtag(type) end;

%-I %+P  prior
%-I      procedure outconstspec(newtag,type); short integer newtag,type;
%-I      begin SCF.outbyte(vconstspec); outtag(newtag); outtag(type) end;

%-I %+P  prior
%-I      procedure outconstdef(spectag,type); short integer spectag,type;
%-I      begin SCF.outbyte(vconst); outtag(spectag); outtag(type) end;

%-I %+P  prior
%-I      procedure outfixrep(fixrep); short integer fixrep;
%-I      begin SCF.outbyte(vfixrep); SCF.out2byte(fixrep) end;

%-I %+P  prior
%-I      procedure outpushc(kind); short integer kind;
%-I      begin SCF.outbyte(vpushc); SCF.outbyte(kind); asd:=asd+1 end;

%-I %+P  prior
%-I      procedure outpush(ptag); short integer ptag;
%-I      begin SCF.outbyte(vpush); outtag(ptag); asd:=asd+1 end;

%-I %+P  prior
%-I      procedure outpushv(ptag); short integer ptag;
%-I      begin SCF.outbyte(vpushv); outtag(ptag); asd:=asd+1 end;

%-I %+P  prior
%-I      procedure outpushcaddr(kind,ptag); short integer kind,ptag;
%-I      begin outpushc(kind); outtag(ptag) end;

%-I %+P  prior
%-I      procedure outpushcint(i); integer i;
%-I      begin SCF.outbyte(vpushc); outinteger(i); asd:=asd+1 end;

%+P      prior
         procedure outsimplevalue(type,index); short integer type,index;
         begin SCF.outbyte(vopc(type));
               if type=ICHAR then SCF.outbyte(index)
          else if type<>ITRUE and!then; type<>IFALS and!then; type<>INONE
               then outstring(index);
         end;

%+P      prior
         procedure outpushsimc(ci,type); short integer ci,type;
         begin ! To output NONE,TRUE or FALSE type must be
                       INONE,ITRUE or IFALS.
                 For a character type=ICHAR and ci=rank of character.
                 For type=IINTG,IREAL or ILONG ci shall be its
                 symtab index. Should not be called for type=ITEXT ;
               outpushc((vopc(type)));
               if type=ICHAR then SCF.outbyte(ci)
          else if IINTG<=type and!then; type<=ILONG then outstring(ci);
         end;

%-I %+P  prior
%-I      procedure textval(txtindex); short integer txtindex;
%-I      begin SCF.outbyte(vtext); outlongstring(txtindex) end;

%-I %+P  prior
%-I      procedure outcdot(ptag); short integer ptag;
%-I      begin SCF.outbyte(vcdot); outtag(ptag) end;

%-I %+P  prior
%-I      procedure outaddrconst(kind,ptag); short integer kind,ptag;
%-I      begin SCF.outbyte(kind); outtag(ptag) end;

%-I %+P  prior
%-I      procedure outsizeconst(kind,ptag); short integer kind,ptag;
%-I      begin SCF.outbyte(kind); outtag(ptag) end;

%-I %+P  prior
%-I      procedure outcompare(rel); short integer rel;
%-I      begin SCF.outbyte(vcompare);
%-I            SCF.outbyte(vopc(rel)); asd:=asd-1;
%-I      end;

%-I %+P  prior
%-I      procedure outbinary(oper); short integer oper;
%-I      begin SCF.outbyte(vopc(oper)); asd:=asd-1 end;

%-I %+P  prior
%-I      procedure outunary(oper); short integer oper;
%-I      SCF.outbyte(vopc(oper));

%-I %+P  prior
%-I      procedure outconvert(type); short integer type;
%-I      begin SCF.outbyte(vconvert); outtag(typetag(type)) end;

%-I %+P  prior
%-I      procedure outmain; SCF.outbyte(vmain);

%-I %+P  prior
%-I      procedure outprogram(pstring); short integer pstring;
%-I      begin SCF.outbyte(vprogram); outstring(pstring) end;

%-I %+P  prior
%-I      procedure outendprogram; SCF.outbyte(vendprogram);

%-I %+P  prior
%-I      procedure outbseg;
%-I      begin SCF.outbyte(vbseg); pushasd; asd:=0 end;

%-I %+P  prior
%-I      procedure outeseg;
%-I      begin SCF.outbyte(veseg); checkasdzero; popasd end;

%-I %+P  prior
%-I      procedure outlocate;
%-I      begin SCF.outbyte(vlocate); asd:=asd-1 end;

%-I %+P  prior
%-I      procedure outfetch; SCF.outbyte(vfetch);

%-I %+P  prior
%-I      procedure outderef; SCF.outbyte(vderef);

%-I %+P  prior
%-I      procedure outindex;
%-I      begin SCF.outbyte(vindex); asd:=asd-1 end;

%-I %+P  prior
%-I      procedure outindexv;
%-I      begin SCF.outbyte(vindexv); asd:=asd-1 end;

%-I %+P  prior
%-I      procedure outpop;
%-I      begin SCF.outbyte(vpop); asd:=asd-1 end;

%-I %+P  prior
%-I      procedure outpopall; if asd <> 0 then
%-I      begin SCF.outbyte(vpopall); SCF.outbyte(asd); asd:=0 end;

%-I %+P  prior
%-I      procedure outdup;
%-I      begin SCF.outbyte(vdup); asd:=asd+1 end;

%-I %+P  prior
%-I      procedure outpushlen;
%-I      begin SCF.outbyte(vpushlen); asd:=asd+1 end;

%-I %+P  prior
%-I      procedure outsave;
%-I      begin SCF.outbyte(vsave); asd:=asd-1 end;

%-I %+P  prior
%-I      procedure outrestore;
%-I      begin SCF.outbyte(vrestore); asd:=asd-1 end;

%-I %+P  prior
%-I      procedure outassign;
%-I      begin SCF.outbyte(vassign); asd:=asd-2 end;

%-I %+P  prior
%-I      procedure outupdate;
%-I      begin SCF.outbyte(vupdate); asd:=asd-1 end;

%-I %+P  prior
%-I      procedure outrupdate;
%-I      begin SCF.outbyte(vrupdate); asd:=asd-1 end;

%+P      prior  ! - not macro - pje jan 87;
         procedure outempty;
         begin SCF.outbyte(vempty); checkasdzero;
               if waitingline > 0 then
               begin outline(waitingline); waitingline:=0 end;
         end;

%-I %+P  prior
%-I      procedure outeval; SCF.outbyte(veval);

%-I %+P  prior
%-I      procedure outselect(attribute); short integer attribute;
%-I      begin SCF.outbyte(vselect); outtag(attribute) end;

%-I %+P  prior
%-I      procedure outselectv(attribute); short integer attribute;
%-I      begin SCF.outbyte(vselectv); outtag(attribute) end;

%-I %+P  prior
%-I      procedure outrefer(typetag); short integer typetag;
%-I      begin SCF.outbyte(vrefer); outtag(typetag) end;

%-I %+P  prior
%-I      procedure outremote(attribute); short integer attribute;
%-I      begin SCF.outbyte(vremote); outtag(attribute) end;

%-I %+P  prior
%-I      procedure outremotev(attribute); short integer attribute;
%-I      begin SCF.outbyte(vremotev); outtag(attribute) end;

%-I %+P  prior
%-I      procedure outaccess(aindex,attribute);
%-I      short integer aindex,attribute;
%-I      begin SCF.outbyte(vaccess); SCF.outbyte(aindex);
%-I            outtag(attribute); asd:=asd+1;
%-I      end;

%-I %+P  prior
%-I      procedure outaccessv(aindex,attribute);
%-I      short integer aindex,attribute;
%-I      begin SCF.outbyte(vaccessv); SCF.outbyte(aindex);
%-I            outtag(attribute); asd:=asd+1;
%-I      end;

%-I %+P  prior
%-I      procedure outskipif(rel); short integer rel;
%-I      begin SCF.outbyte(vskipif); SCF.outbyte(vopc(rel));
%-I            asd:=asd-2; pushasd;
%-I      end;

%-I %+P  prior
%-I      procedure outendskip;
%-I      begin SCF.outbyte(vendskip); checkasdzero; popasd end;

%-I %+P  prior
%-I      procedure outif(rel); short integer rel;
%-I      begin SCF.outbyte(vif); SCF.outbyte(vopc(rel));
%-I            asd:=asd-2; pushasd;
%-I      end;

%-I %+P  prior
%-I      procedure outelse;
%-I      begin SCF.outbyte(velse); exchasd end;

%-I %+P  prior
%-I      procedure outendif;
%-I      begin SCF.outbyte(vendif); checkasdequal; popasd end;

%-I %+P  prior
%-I      procedure outlabelspec(newtag); short integer newtag;
%-I      begin SCF.outbyte(vlabelspec); outtag(newtag) end;

%-I %+P  prior
%-I      procedure outlabeldef(spectag); short integer spectag;
%-I      begin SCF.outbyte(vlabel); outtag(spectag); checkasdzero end;

%-I %+P  prior
%-I      procedure outgoto;
%-I      begin SCF.outbyte(vgoto); asd:=asd-1; checkasdzero end;

%-I %+P  prior
%-I      procedure outfjumpif(rel,dest); short integer rel,dest;
%-I      begin SCF.outbyte(vfjumpif); SCF.outbyte(vopc(rel));
%-I            SCF.outbyte(dest); asd:=asd-2;
%-I      end;

%-I %+P  prior
%-I      procedure outbjumpif(rel,dest); short integer rel,dest;
%-I      begin SCF.outbyte(vbjumpif); SCF.outbyte(vopc(rel));
%-I            SCF.outbyte(dest); indexused(dest):=false; asd:=asd-2;
%-I      end;

%-I %+P  prior
%-I      procedure outfjump(dest); short integer dest;
%-I      begin SCF.outbyte(vfjump); SCF.outbyte(dest); checkasdzero end;

%-I %+P  prior
%-I      procedure outfdest(dest); short integer dest;
%-I      begin SCF.outbyte(vfdest); SCF.outbyte(dest); indexused(dest):=false;
%-I            checkasdzero;
%-I      end;

%+P      prior
         procedure outfdestKEEP(dest); short integer dest;
         begin SCF.outbyte(vfdest); SCF.outbyte(dest); checkasdzero end;

%-I %+P  prior
%-I      procedure outbdest(dest); short integer dest;
%-I      begin SCF.outbyte(vbdest); SCF.outbyte(dest); checkasdzero end;

%-I %+P  prior
%-I      procedure outbjump(dest); short integer dest;
%-I      begin SCF.outbyte(vbjump); SCF.outbyte(dest); indexused(dest):=false;
%-I            checkasdzero;
%-I      end;

%-I %+P  prior
%-I      procedure outdelete(ptag); short integer ptag;
%-I      begin SCF.outbyte(vdelete); outtag(ptag); checksavedstacks end;

%-I %+P  prior
%-I      procedure outprecall(profile); short integer profile;
%-I      begin SCF.outbyte(vprecall); outtag(profile); asd:=asd+1 end;

%-I %+P  prior
%-I      procedure outcall(body,exportnum); short integer body, exportnum;
%-I      begin SCF.outbyte(vcall); outtag(body); asd:=asd-1+exportnum end;

%-I %+P  prior
%-I      procedure outasscall(profile); short integer profile;
%-I      begin SCF.outbyte(vasscall); outtag(profile) end;

%-I %+P  prior
%-I      procedure outasspar;
%-I      begin SCF.outbyte(vasspar); asd:=asd-1 end;

%-I %+P  prior
%-I      procedure outassrep(depth); short integer depth;
%-I      begin SCF.outbyte(vassrep); SCF.outbyte(depth); asd:=asd-depth end;

%-I %+P  prior
%-I      procedure outrepcall(depth,profile); short integer depth,profile;
%-I      begin SCF.outbyte(vrepcall); SCF.outbyte(depth);
%-I            outtag(profile); asd:=asd-depth+1;
%-I      end;

%-I %+P  prior
%-I      procedure outmoduledefhead(modid,check); short integer modid,check;
%-I      begin SCF.outbyte(vmodule); outstring(modid); outstring(check) end;

%-I %+P  prior
%-I      procedure outtagindex(itag,xtag); short integer itag,xtag;
%-I      begin SCF.outbyte(vtag); outtag(itag); SCF.out2byte(xtag) end;

%-I %+P  prior
%-I      procedure outbody; SCF.outbyte(vbody);

%-I %+P  prior
%-I      procedure outendmodule; SCF.outbyte(vendmodule);

%-I %+P  prior
%-I      procedure outinfo(pstring); short integer pstring;
%-I      begin SCF.outbyte(vinfo); outstring(pstring) end;

%-I %+P  prior
%-I      procedure outline(pnumber); short integer pnumber;
%-I      begin SCF.outbyte(vline); SCF.out2byte(pnumber) end;

%-I %+P  prior
%-I      procedure outsetswitch(sw,val); short integer sw,val;
%-I      begin SCF.outbyte(vsetswitch);
%-I            SCF.outbyte(sw); SCF.outbyte(val);
%-I      end;

%title ******  Stack for textually recursive calls  *******

         ref(quantity)array callstack, parstack (0:maxcalldepth);
         character     array statusstack (0:maxcalldepth); !zero never used;
         short integer array parnostack  (0:maxcalldepth); !zero never used;
         short integer calldepth; !*** pointer to first free ***;
         !*** the following variables contain top of stack ***;
         ref(quantity) curcall, curpar; character curstatus;
         short integer curparno;

%+P      prior
         procedure pushcall(q); ref(quantity)q;
         begin ! curpar and curstatus are nullified;
               if calldepth > maxcalldepth then
               StopScode_1(577) !calldepth overflow;
          else if calldepth>=1 then
               begin callstack  (calldepth):- curcall;
                     parstack   (calldepth):- curpar;
                     statusstack(calldepth):= curstatus;
                     parnostack (calldepth):= curparno;
               end;
               calldepth:=calldepth+1;
               curcall:-q; curpar:-none; curstatus:='!0!'; curparno:=0;
         end of pushcall;

%+P      prior
         procedure popcall;
         begin if calldepth<=0 then StopScode_1(578) !calldepth underflow; else
               calldepth:=calldepth-1;
               if calldepth>0 then
               begin curcall:-   callstack  (calldepth);
                     curpar:-    parstack   (calldepth);
                     curstatus:= statusstack(calldepth);
                     curparno:=  parnostack (calldepth);
               end else begin                              !pje 20/8 ;
                     curcall:- curpar:- none;              !pje 20/8 ;
                     curstatus:='!0!';  curparno:=0;       !pje 20/8 ;
               end;                                        !pje 20/8 ;
         end;


%title ******   The system for handling indices   *******

%        indices are allocated in a round-robin fashion to speed up getnewindex

         boolean array indexused(0:max_index);    ! zero never used;
         short integer curindex;  !last generated index;

%+P      prior
         procedure getnewindex;
         begin short integer i;
               i:=curindex+1;
               while i<=max_index do
                  if indexused(i) then i:=i+1 else goto found;
               i:=1;
               while i<=curindex do
                  if indexused(i) then i:=i+1 else goto found;
               StopScode_1(579); goto E; !all indices used;
         found: indexused(i):=true; curindex:=i;
       E:end;


        !********** The following stack etc. is used for ********
         ********** controlling internal jumps  etc.     ********;

%        'jumpstack' is used for destination indices of jump
%        instructions. In the coding of inspect-statements some indices
%        will be pushed on the stack as negative numbers, in order to
%        let the sign of the top of the stack indicate the actual
%        situation ;

         short integer array jumpstack(0:maxjumpdepth); !zero never used;
         short integer curjump; comment: Top of stack pointer;

%+P      prior
         procedure pushjump(index); short integer index;
         begin curjump:=curjump+1;
               if curjump>maxjumpdepth then StopScode_1(580)!jumpdepth overflow;
               else jumpstack(curjump):=index;
         end;

%+P      prior
         short integer procedure popjump;
         begin popjump:=jumpstack(curjump); curjump:=curjump-1 end;


!*********  The procedures STARTPAR, TERMPAR and TERMSPECPROCALL *****;

         character clf;

%+P      prior
         procedure termpar;
         begin clf:=if curpar is extquantity
                    then curpar qua extquantity.classific else ' ';
               if clf='Q' then  ! nothing ; else
               if clf='F' or!else; clf='P' or!else; clf='!1!' then
               begin ! Parameter value on TOS (GADDR value in case of by name);
                     if rank(curpar.categ)=IVALU then
                     begin ! Scheme MakeValueCopies: ;
                           if rank(curpar.kind)=IARRA then
                           begin outpush(Z_TMP);
                                 outselect(Z_QUANT_ARR);
                                 outrupdate;
                                 outpop;
                                 expandsave;
                                 outprecall(Z_ARR_COP_T1);
                                 outpushcint(rtstypecode(rank(curpar.type)));
                                 outasspar;
                                 outcall(Z_ARR_COP_T2,0);
                                 expandrestore;
                                 outpush(Z_TMP);
                                 outselectv(Z_QUANT_ARR);
                           end array by value else
                           if rank(curpar.type)=ITEXT then !must be simple kind;
                           begin outpush(Z_TMP);
                                 outselect(Z_QUANT_TXT);
                                 outrupdate;
                                 outpop;
                                 expandsave;
                                 outprecall(Z_COPY1);
                                 outpush(Z_TMP);
                                 outselectv(Z_QUANT_TXT);
                                 outasspar;
                                 outcall(Z_COPY2,1);
                                 outpush(Z_TMP);
                                 outselect(Z_QUANT_TXT);
                                 outrupdate;
                                 outpop;
                                 expandrestore;
                                 outpush(Z_TMP);
                                 outselectv(Z_QUANT_TXT);
                           end text by value;
                     end by value;
                     outasspar;
               end else
               if rank(curpar.categ)=INAME then ! nothing ; else
               begin outassign;
                     if rank(curpar.categ)=IVALU then
                     begin if rank(curpar.type)=ITEXT and!then;
                              rank(curpar.kind)=IIDN then
                           begin outasscall(Z_txt_by_va1);
                                 outpushcaddr(vcaaddr,curpar.ftag+quantdisp);
                                 outasspar;
                                 outcall(Z_txt_by_va2,1);
                           end else
                           if rank(curpar.kind)=IARRA then
                           begin outasscall(Z_arr_by_va1);
                                 outpushcaddr(vcaaddr,curpar.ftag+quantdisp);
                                 outasspar;
                                 outpushcint(rtstypecode(rank(curpar.type)));
                                 outasspar;
                                 outcall(Z_arr_by_va2,1);
                           end;
                     end categ=IVALU;
               end;
         end termpar;

%+P      prior
         procedure termspecprocall;
         begin ! Used to terminate the call on a specified procedure (i.e. not
                 virtual or formal). The transmission of parameters is ended.;
               short integer ctype;
               clf:=if curcall is extquantity then
                       curcall qua extquantity.classific else ' ';
               ctype:=rank(curcall.type);
               if clf=' ' or!else; clf='N' then begin
                     if curpar =/= none
%+K                     or!else; (rank(curcall.kind)= IPROC and!then;
%+K                               rank(curcall.categ)=IDCLI and!then;
%+K                               curcall.descr.thisused)
                     then begin ! Terminate call with parameters ;
                           outasscall(Z_i_pro1);
                           outcall(Z_i_pro2,0);
                     end;
                     expandrestore;
                     if ctype <> INOTY then
                     begin outpush(Z_tmp);
                           outselectv(Z_quant_pnt);
                           outremotev(resulttag(ctype));
                           outeval;
                     end;
               end normal Simula procedure else
               if clf='I' then begin  !*** in-line coded procedure call ***;
                     if curcall.ident=   RANKindex or!else;
                        curcall.ident=   CHARindex or!else;
                        curcall.ident=ISORANKindex or!else;
                        curcall.ident=ISOCHARindex
                     then begin
                        outconvert(ctype);
                     end
                else if curcall.ident=REMindex
                     then begin
                        outinstr(102); !*** S-code rem, nowhere else;
                        asd:=asd-1;
                     end
                else if curcall.ident= LOADCHARindex or!else;
                        curcall.ident=STORECHARindex
                     then begin
                        outpush(Z_tmp); outselect(Z_quant_int);
                        outrupdate; outpop;
                        outpush(Z_txttmp); outrupdate; outpop;
                        outpush(Z_txttmp); outselect(Z_txtqnt_ent);
                                           outremote(Z_txtent_cha);
                        outpush(Z_txttmp); outselectv(Z_txtqnt_sp);
                        outpush(Z_tmp); outselectv(Z_quant_int);
                        outbinary(IPLUS);
                        if curcall.ident=LOADCHARindex then outindexv
                        else begin outindex; outrupdate; outpop end
                     end
                else if curcall.ident=SIGNindex
                     then begin
%  TEMP UT              outfetch; outdup; outpushzero(ctype);
  !TEMP;                outfetch; outdup;
  !TEMP;                outpushsimc(zerostringindex,ctype);
                        outif(INE);
%  TEMP UT                 outpushzero(ctype);
%  TEMP UT                 outif(ILT); outpushintone(true);
%  TEMP UT                 outelse;    outpushintone(false);
  !TEMP;                   outpushsimc(zerostringindex,ctype);
  !TEMP;                   outif(ILT); outpushcint(-1);
  !TEMP;                   outelse;    outpushcint( 1);
                           outendif;
                        if ctype>IINTG
                        then begin !*** convert to IINTG;
                           outelse; outconvert(IINTG) end;
                        outendif;
                     end
                else if curcall.ident=MINindex or!else;
                        curcall.ident=MAXindex
                     then begin
                        ctype:=quantvarianttag(ctype);
                        outpush(Z_tmp); outselect(ctype);
                        outrupdate; outpop;
                        outfetch; outdup;
                        outpush(Z_tmp); outselectv(ctype);
                        outif(if curcall.ident=MINindex then IGT else ILT);
                           outpop; outpush(Z_tmp); outselectv(ctype);
                        outendif;
                     end
                else if curcall.ident=ABSindex
                     then begin
                        outfetch; outdup;
%  TEMP UT              outpushzero(ctype);
  !TEMP;                outpushsimc(zerostringindex,ctype);
                        outif(ILT); outunary(IUMNS); outendif;
                     end
                else if curcall.ident=SOURCELINEindex
                     then begin
                        outpushcint(linenr);
                     end
                     else internalerror(671)
               end else
               if clf='V' or!else; clf='W' then ! nothing; else
               begin ! Terminate routine procedure call;
                     if rank(curcall.type)=INOTY
                     then outcall(curcall.ftag+bodydisp,0)
                     else outcall(curcall.ftag+bodydisp,1);
                     if saveemitted(saveindex) then
                     begin ! A text quantity on TOS;
                           outpush(Z_TMP);
                           outselect(Z_QUANT_TXT);
                           outrupdate;
                           outpop;
                           expandrestore;
                           outpush(Z_TMP);
                           outselectv(Z_QUANT_TXT);
                           outeval;
                     end else
                     saveindex:=saveindex-1;
               end routine procedure call;
         end termspecprocall;


%+K      procedure gen_quick_instances(q);ref(quantity)q;
%+K      begin
%+K         ! q denotes the head of a block. The procedure generates
%+K           code to generate the instances of quick procedures within
%+K           the block q ;
%+K
%+K         ref(quantity)qty;
%+K
%+K         qty:-q.descr.fpar;
%+K         while qty=/=none do
%+K         begin
%+K            if (if rank(qty.kind)=IPROC then
%+K                   qty.descr.thisused else false) then
%+K            begin
%+K               ! curins is the block enclosing the quick
%+K                 procdures  ;
%+K
%+K               outprecall(Z_a_pro1);
%+K               outpush(Z_curins);
%+K               outasspar;
%+K               outpushcaddr(vcoaddr,qty.ftag+prototypedisp);
%+K               outasspar;
%+K               outcall(Z_a_pro2,1);
%+K               outpush(Z_curins);
%+K               outremote(qty.ftag+instrefdisp);
%+K               outrupdate;
%+K               outpop;
%+K            end;
%+K            qty:-qty.next;
%+K         end;
%+K      end;



!********************************************************************;
!********   PROCEDURES PRODUCING SMALL SEQUENCES OF S-CODE:  ********;
!********************************************************************;


     !  **********   STATICENCL   ********** ;

     short integer st_rblev; !Relative RT block level of static enclosure;
                             ! Used at LIDCLP, LIDCLC ;
%+P  prior
     procedure staticencl(q); ref(quantity)q;
%    ! For a directly visible attribute q, pusch OADDR of static
%      enclosure on stack ;
%    ! Corresponds to S-Code scheme StaticEncl, except that
%      it is not used for remotely accessed quantities ;
     begin short integer st_rblev;
        if q.encl.blev<0 then
        begin
           outpushv(Z_bio);
           if q.encl.blev>-3 then
              outremotev( if q.encl.blev=-1 then Z_bio_sysout
                          else ! blev=-2; Z_bio_sysin );
        end else
        begin
           outpushv(Z_curins);

           st_rblev:=crtblev-q.encl.rtblev;
           while st_rblev>0 do begin
                 outremotev(Z_entity_sl); st_rblev:=st_rblev-1 end;

           ! Check for attribute visible through inspection;
           ! (Note that this is not concerned with labels local to
              a connection.  For these we have q.encl.kind=IFORE) ;
           if rank(q.encl.kind)=IINSP then outremotev(conpointtag(q.encl));

        end ;
     end staticencl;


     !  *************     addrPARQNT      **************** ;

%+P  prior
     procedure addrPARQNT(q,gaddr);
     ref(quantity) q;   ! q.categ=INAME ;
     boolean gaddr;     ! True if GADDR value on TOS is wanted;
     begin
        staticencl(q);
        outremote(q.ftag+quantdisp); ! tag of PARQNT ;
        if gaddr then outderef;
     end addrPARQNT;


     !  *************     GADDRval      **************** ;

%+P  prior
     procedure GADDRval;
     ! Push address of the quantity described by opq on TOS,
       as a GADDR value.  Used in connection of transmission by address,
       i.e. by name transmission to non-Simula procedure, and in
       connection with text name variable preceding := or .<procedure> ;
     ! Called from procLISSWA (SINGLE-ACTUAL) and from LIIDNP
       (SINGLE-VAR) ;
     begin short integer Z1, Z2; ! code shortened 15/1 87 - PJE;
        if rank(opq.categ)=INAME then
        begin
           addrPARQNT(opq,false);
           outselectv(Z_parqnt_sem);
           outpushc(vtrue);
           outif(IEQ);
            addrPARQNT(opq,false);
            outselectv(Z_parqnt_ent);
            addrPARQNT(opq,false);
            outselectv(Z_parqnt_fld);
            outlocate;
           outelse;
           if rank(opq.kind)=IIDN and!then; rank(opq.type)=ITEXT then
           begin
               expandsave;
               outprecall(Z_b_txt_adr1);
               addrPARQNT(opq,true);
               outasspar;
               outcall(Z_b_txt_adr2,0);
               expandrestore;
             ! outprecall(Z_e_txt_adr1); Z1:=Z_e_txt_adr1;
             ! addrPARQNT(opq,true);
             ! outasspar;
             ! outcall(Z_e_txt_adr2,1);  Z2:=Z_e_txt_adr2;
             !outendif;
           end simple text else
           begin
               addrPARQNT(opq,false);
               outselectv(Z_parqnt_ap);
               outremotev(Z_pardes_cod);
               outpushcint(par_thk_ass);
               outif(INE);  !outskipif(IEQ);               !850522 - removed;
                expandsave;
                outprecall(Z_b_fnp_ass1);
                addrPARQNT(opq,true);
                outasspar;
                outcall(Z_b_fnp_ass2,0);
                expandrestore;
                outpushc(vonone);   ! Down to 'outpop' - crazy code to ;
               outelse;             ! satisfy S-code def. of if-endif;
                outpushc(vonone);
               outendif;    !outendskip;                  !850522 - removed;
               outpop;              ! - see above;
             ! outprecall(Z_e_fnp_adr1); Z1:=Z_e_fnp_adr1;
             ! addrPARQNT(opq,true);
             ! outasspar;
             ! outcall(Z_e_fnp_adr2,1);  Z2:=Z_e_fnp_adr2;
             !outendif;
           end;
           outprecall(Z1);addrPARQNT(opq,true);outasspar;outcall(Z2,1);outendif;
        end name quantity else begin
           staticencl(opq);
           outremote(opq.ftag+quantdisp);
           outderef;
        end;
     end GADDRval;


     !  ******    ACCESS_SUBCLASS,  QUATEST,  OUTNONETEST    ******** ;


%+P      prior
         procedure access_subclass(labelattrtag); short integer labelattrtag;
         ! Called at declaration end and at inner of class body,
           opq will be the corresponding class.  Generate code to
           jump if actual object belongs to a subclass ;
         ! labelattrtag is either Z_cpptp_dcl or Z_cpptp_stm ;
         ! This procedure replaces the previous 'outinner' ;
         begin
            outpushv(Z_curins);
            outremotev(Z_entity_pp);
            outremote(Z_cpptp_pre);
            outpushcint(opq.plev+1);
            outindex;
            outdup;
            outpushc(vonone);
            getnewindex; outfjumpif(IEQ,curindex);
             outremotev(labelattrtag);
             outgoto;
            outfdest(curindex);
         end access_subclass;

%+P      prior
         procedure quatest(q); ref(quantity)q;
         begin
            ! Used for both explicit and implicit qua, appropriate
              none-test must be generated outside this procedure ;
            outdup; outremotev(Z_entity_pp);
            outdup; outremotev(Z_cpptp_plv);
            outpushcint(q.plev);
            getnewindex; iii:=curindex; outfjumpif(ILT,iii);
             outremote(Z_cpptp_pre);
             outpushcint(q.plev); outindexv;
             outpushcaddr(vcoaddr,q.ftag+prototypedisp);
             outskipif(IEQ);
             outpopall;
             outfdest(iii);
            outprecall(Z_err_qua1);
            outcall(Z_err_qua2,0);
            outendskip;
         end of quatest;

%+P      prior
         procedure outnonetest(somenone,errtype);
         short integer somenone; ! somenone may be vonone or vnowhere ;
         short integer errtype;  ! errtype may be IQUA or IDOT (or IVIRT ???) ;
         begin outdup;
               outpushc(somenone);
               outskipif(INE);

            if errtype=IQUA then
            begin
               outprecall(Z_err_qua1);
               outcall(Z_err_qua2,0);
            end else
            ! errtype=IDOT;
            begin
               outprecall(Z_err_none1);
               outcall(Z_err_none2,0);
            end ;

            outpopall;
            outendskip;
         end of outnonetest;

%+P      prior
         procedure endsubscription(mode); short integer mode;
         begin integer alowb;
            ! produces the last code for subscription ;
            ! Is called at LIARGE, LINEWP and LIARRA ;
            ! mode may be IVALUE or IREF ;

            if curstatus='!1!' then begin inspect curcall do
                  if BoundCheck then !not inline code;
             else if arraylb<>0
                  then begin !special code for 1-dim with constant lb;
                             !    generate IPLUS for negative const;
                       alowb:=idname(arraylb).getint;
                       if alowb<>0 then begin
                          outpushcint(abs(alowb));
                          outbinary(if alowb>0 then IMINU else IPLUS);
                       end;
                       goto INDEXOUT;
                  end;
                  outasspar; outcall(Z_arr_1_ind2,0);
                  outremote(arr1elttag(rank(curcall.type)));
            end
       else if curstatus='!2!' then begin
                  outasspar; outcall(Z_arr_2_ind2,0);
                  outremote(arr2elttag(rank(curcall.type))) end
            else begin
                  outassrep(rank(curstatus)); outcall(Z_arr_g_ind2,0);
                  outremote(arr3elttag(rank(curcall.type)));
            end;
            ! TOS=array reference, TMP.INT is linearized index ;
% moved to             -- outremote( arrelttag( rank(curcall.type),
% separate cases above --       if curstatus>2 then 3 else curstatus));
            outpush(Z_tmp);
            outselectv(Z_quant_int);
  INDEXOUT: if mode=IVALU then outindexv  ! VAL mode on stack ;
            else outindex;                ! REF mode on stack ;
            outeval;
         end;





!  ***** SAVEPARAM,  RESTOREPARAM,  EXPANDSAVE, EXPANDRESTORE  ****** ;

%+P      prior
         procedure saveparam;
         begin
            outdup;
            outremote(Z_instance_d);
            outpushv(Z_curins);
            outremotev(Z_instance_d);
            outassign;
            outpushv(Z_curins);
            outremote(Z_instance_d);
            outrupdate;
            outpop;
         end saveparam;

%+P      prior
         procedure restoreparam;
         begin outpushv(Z_curins); outremotev(Z_instance_d);
               outpushv(Z_curins); outremote(Z_instance_d);
               outdup; outremotev(Z_instance_d); outassign;
         end saveparam;


         boolean array saveemitted(0:50);
         short integer saveindex;

%+P      prior
         procedure expandsave;
         begin saveindex:=saveindex+1;
               if asd <> 0 then
               begin outpushlen; outasscall(Z_pre_sav1);
                     outcall(Z_pre_sav2,1); outsave; pushasd; asd:=0;
                     saveemitted(saveindex):=true;
               end else saveemitted(saveindex):=false;
         end of expandsave;

%+P      prior
         procedure expandrestore;
         begin if saveemitted(saveindex) then
               begin outprecall(Z_restore1); outcall(Z_restore2,0);
                     outpush(Z_RSTR); outrestore; checkasdzero; popasd;
               end;
               saveindex:=saveindex-1;
         end expandrestore;


   !  **********   GET_LABQNT,   GET_SWTQNT   ********** ;

         procedure get_LABQNT(opq); ref(quantity)opq;
         ! opq.kind=ILABE ;
         ! push LABQNT on TOS ;
         begin
            if rank(opq.categ)=IDCLI then
            begin
               outprecall(Z_make_lab1);
               staticencl(opq);
                  ! If label is inside an inspect statement, this
                    gives a reference to the enclosing 'proper' block;
               outasspar;
               outpushcaddr(vcpaddr,opq.ftag+quantdisp);
               outasspar;
               outpushcint(conlevel(opq));
               outasspar;
               outcall(Z_make_lab2,1);
            end else
            if rank(opq.categ)=IFRMP then
            begin
               staticencl(opq);
               outremotev(opq.ftag+quantdisp);
            end else
            if rank(opq.categ)=IVIRT then
            begin
               outprecall(Z_make_v_l1);
               staticencl(opq);
               outasspar;
               outpushcint(opq.virtno-1);
               outasspar;
               outcall(Z_make_v_l2,1);
            end else
            if rank(opq.categ)=INAME then
            begin
               expandsave;
               outprecall(Z_b_fnp_acc1);
               addrPARQNT(opq,true);
               outasspar;
               outcall(Z_b_fnp_acc2,0);
               expandrestore;

               outprecall(Z_e_acc_lab1);
               addrPARQNT(opq,true);
               outasspar;
               outcall(Z_e_acc_lab2,1);
            end;
         end get_LABQNT;


         procedure get_SWTQNT(opq); ref(quantity)opq;
         ! opq.kind=ISWIT ;
         ! push SWTQNT on TOS ;
         begin
            if rank(opq.categ)=IDCLI then
            begin
               outprecall(Z_make_swt1);
               staticencl(opq);
               outasspar;
               outpushcaddr(vcoaddr,opq.ftag+quantdisp);
               outasspar;
               outcall(Z_make_swt2,1);
            end else
            if rank(opq.categ)=IFRMP then
            begin
               staticencl(opq);
               outremotev(opq.ftag+quantdisp);
            end else
            if rank(opq.categ)=IVIRT then
            begin
               outprecall(Z_make_v_s1);
               staticencl(opq);
               outasspar;
               outpushcint(opq.virtno-1);
               outasspar;
               outcall(Z_make_v_s2,1);
            end else
            if rank(opq.categ)=INAME then
            begin
               expandsave;
               outprecall(Z_b_fnp_acc1);
               addrPARQNT(opq,true);
               outasspar;
               outcall(Z_b_fnp_acc2,0);
               expandrestore;

               outprecall(Z_e_acc_swt1);
               addrPARQNT(opq,true);
               outasspar;
               outcall(Z_e_acc_swt2,1);
            end;
         end get_SWTQNT;

% UT     short integer precall,asscall;

         procedure get_PROQNT(q,callmode);
            ref(quantity)q; boolean callmode; !short integer callmode;
         begin
            ! written in accordance with Albatross,
              q.kind=IPROC
              pushes a procedure quant on the stack ;

            ! callmode may have two values: true:precall or false:asscall;

            inspect q do
            begin
               if rank(categ)=IDCLI or!else; rank(categ)=IEXTR then
               begin
                  if callmode !=precall; then
                  begin
                     outprecall(Z_make_pro1);
                     staticencl(q);
                     outasspar;
                  end else
                     outasscall(Z_make_pro1);
                  outpushcaddr(vcoaddr,ftag+prototypedisp);
                  outasspar;
                  if rank(type)=IREF then
                     outpushcaddr(vcoaddr,prefqual.ftag+prototypedisp)
                  else outpushc(vonone);
                  outasspar;
                  outcall(Z_make_pro2,1);

               end  else
               if rank(categ)=IVIRT then
               begin
                  if callmode !=precall; then
                  begin
                     outprecall(Z_make_v_p1);
                     staticencl(q);
                     outasspar;
                  end else
                     outasscall(Z_make_v_p1);
                  outpushcint(virtno-1);
                  outasspar;
                  outcall(Z_make_v_p2,1);

               end else
               if rank(categ)=IFRMP then
               begin
                  staticencl(q);
                  outremotev(ftag+quantdisp);
               end else
               if rank(categ)=INAME then
               begin
                  expandsave;
                  outprecall(Z_b_fnp_acc1);
                  addrPARQNT(q,true);
                  outasspar;
                  outcall(Z_b_fnp_acc2,0);
                  expandrestore;
                  outprecall(Z_e_acc_pro1);
                  addrPARQNT(q,true);
                  outasspar;
                  outcall(Z_e_acc_pro2,1);

               end;
            end inspection of q;
         end get_PROQNT;

         procedure get_ARRPNT(q);
         ! Push pointer to array entity on TOS;
         ref(quantity)q;    ! q.kind=IARRA ;
         begin
            if rank(q.categ)=INAME then
            begin
               expandsave;
               outprecall(Z_b_fnp_acc1);
               addrPARQNT(q,true);
               outasspar;
               outcall(Z_b_fnp_acc2,0);
               expandrestore;

               outprecall(Z_e_acc_arr1);
               addrPARQNT(q,true);
               outasspar;
               outcall(Z_e_acc_arr2,1);
            end else
            begin
               staticencl(q);  ! get_ARRPNT not used by remote access;
               outremotev(q.ftag+quantdisp);
            end;
         end get_ARRPNT;

!**********  Procedures getting various sorts of RTS-coding  *******;

%        short integer rtstypelabel,rtstypearray,rtstypedpd,rtstypeproc;

%  NOT USED:
%        short integer procedure rtsblockkind(kind); short integer kind;
%        begin if kind=IBLKB then rtsblockkind:=0 else
%              if kind=IPROC then rtsblockkind:=1 else
%              if kind=ICLAS then rtsblockkind:=2 else
%              if kind=IBPRF then rtsblockkind:=3 else
%                 StopScode_1(584); !rtsblockkind error;
%        end;

%  NOT USED:
%        short integer procedure txtrelcode(rel); short integer rel;
%        begin
%           if rel=ILT then txtrelcode:=1 else
%           if rel=IEQ then txtrelcode:=2 else
%           if rel=ILE then txtrelcode:=3 else
%           if rel=IGT then txtrelcode:=4 else
%           if rel=INE then txtrelcode:=5 else
%           if rel=IGE then txtrelcode:=6 else
%              StopScode_1(585); !txtrelcode error;
%        end;


   ! *********  STACK OF TAGS   ********** ;
   ! The stack is used for tags of connection pointers for each
     connection level, and for tags of PADDR variables for each
     complex-for level ;

       short integer tagstacktop;
            ! Top of stack;
       short integer array tagstack(0:maxblev//2 !maxtagstack-see SCODER0; );
            ! The lower levels of the stack ;
       short integer tagstackdepth;
            ! Current stack depth ;

%+P    prior
       procedure pushtag( tag); short integer tag;
       begin ! Called from LICONB, LIFWHN, LIFOR;
          if tagstackdepth>maxtagstack then StopScode_1(672)
                ! Too deep nesting of connection blocks/complex-for ;
          else tagstack(tagstackdepth):=tagstacktop;
          tagstackdepth:=tagstackdepth+1;
          tagstacktop:=tag;
       end pushtag;

%+P    prior
       procedure poptag;
       begin ! Called from LIOTHW, LICONE, LIFORE ;
          tagstackdepth:=tagstackdepth-1;
          if tagstackdepth<0 then StopScode_1(673) ! tag stack underflow;
          else tagstacktop:=tagstack(tagstackdepth);
       end poptag;


!****** Variables etc. used during treatment of for-lists: *********;

      ref(quantity)forblock; ! The allocated block to which
                             the for-stmt is local;

      ref(brecord)forbrecord; ! The brecord of the for-stmt, kind=IFORE;

      ref(quantity)contvar; ! The quantity of the controlled varibl.;

      ! For the following, see TECHDOC-ALBATROSS:TEXT ;
      ! None of them will ever be ISHOR ;
      character conttype;
      character steptype;
      character untiltype;
      character contsteptype;
      character contuntiltype;
      character testtype;

      character forelemkind; ! 'S':single, 'W':while, 'I':increment;

      boolean complexfor;  ! true if more than one for element;

      short integer forretlabel;! The tag of the label which at any time
                                  is the one we shall return to as far as
                                  we know ;
      short integer stepfastindex;
% NOT USED:
%     short integer procedure mostfloating(t1,t2); short integer t1,t2;
%     begin ! none of t1,t2 will ever be ISHOR ;
%           mostfloating:=
%           if t2=IINTG then t1 else
%           if t1=ILONG then ILONG else
%             ! Remaining possibilites are (IINTG,IREAL), (IINTG,ILONG)
%             (IREAL,IREAL) or (IREAL,ILONG);
%           t2;
%     end mostfloating;

      short integer procedure firstfortag(q); ref(quantity)q;
      begin
      ! The following depends on the number of tags allocated to
        different kinds of blocks in brecord'inttagsetting ;
      ! q must be a proper block (kind= IBLKB, IPROC, ICLAS or IBPRF).
        If it is a procedure it must be the procedure head ;
         firstfortag:=q.ftag+
                      (if rank(q.kind)=ICLAS or!else; rank(q.kind)=IBPRF then 5
%+K               else if rank(q.kind)=IPROC and!then; q.descr.thisused  then 4
                       else 3);
      end firstfortag;

%+P  prior
     procedure forelemstart;
     begin
        if complexfor then
        begin
           forretlabel:=lastusedtag:=lastusedtag+1;
               ! RET label of the for element to follow;
           outlabelspec(forretlabel);
           outpushv(Z_curins);
           outremote(tagstacktop);
           outpushcaddr(vcpaddr,forretlabel);
           outassign;
        end;
        forelemkind:='S'; !Single,if not changed at UNTIL or FOR-WHILE;
     end forelemstart;

%+P  prior
     procedure forelemend;
     begin
        ! Terminate for-element;
        if forelemkind='S' then ! Single ;
        begin
           if complexfor then
           begin
              getnewindex; pushjump(curindex); ! START index;
              outfjump(curindex);
              outlabeldef(forretlabel);
           end
        end else
        if forelemkind='W' then ! For-while ;
        begin
           if lastopi <> -3 or!else; lastopt=ITEXT then
           begin ! Boolean expression has not been coded specially;
              outpushc(vtrue);
              getnewindex; ! if complexfor then START-index
                                            else FINISH-index ;
              pushjump(curindex);
              outfjumpif(if complexfor then IEQ else INE,curindex);
           end;
        end else
        begin
           ! forelemkind='I' - increment ;
           if untiltype <> contuntiltype then outconvert(rank(contuntiltype));
           outbinary(IMINU);
           if contsteptype <> testtype then
           begin
              outpush(Z_tmp);
              outselect(quantvarianttag(rank(testtype)));
              outrupdate;
              outpop;
              outconvert(rank(testtype));
              outpush(Z_tmp);
              outselectv(quantvarianttag(rank(testtype)));
           end else
           if contuntiltype <> testtype then outconvert(rank(testtype));
           outbinary(IMULT);
           outpushsimc(zerostringindex,rank(testtype));
           if complexfor then
           begin
              getnewindex;                ! STARTiE index ;
              jjj:=popjump;               ! NEXTi index;
              pushjump(curindex);
              outfjumpif(ILE,curindex);
              outfdest(jjj);
           end else
           begin
              ! This is the end of the one and only 'I' element, i.e.
                code for the controlled statement will follow directly ;
              iii:=popjump ;                   ! START index;
              getnewindex; pushjump(curindex); ! FINISH2 index;
              outfjumpif(IGT,curindex);
              outfdest(iii);
           end;
        end
     end forelemend;

!*************** Fast-For Information *****************************;
       ! Used for info that has to be stacked from start of fast-for
         (actually stacked at UNTIL-FAST) until END-FOR-FAST ;

       class ffi(contvar,stepindex,untilindex,untilopq);
             ref(quantity) contvar;   ! controlled variable ;
             short integer stepindex; ! if stepindex>0 then
                                         stepconstant is symtab(stepindex)
                                        else stepconstant is zero;
             short integer untilindex;! if untilindex<>0 then
                                         untilexpr is symtab(abs(untilindex))
                                        else untilexpr is in untilopq;
             ref(quantity) untilopq;  ! if untilopq=/=none then untilexpr
                                        is the single ident untilopq ;
       begin
             ref(ffi) prev;           ! ffi objects are stacked in a LIFO ;
             prev:-curffi;
       end ffi;

       ref(ffi) curffi;       ! The first in the LIFO stack of ffi's ;

!***************** end of declarations to for list treatment *******;

!****** Utilities used for treatment of connection blocks: *********;

      short integer procedure conpointtag(brc);
      ref(brecord)brc;
      ! Invariant: brc.kind=IINSP,i.e. brc is a connection copy;
      ! Get tag of corresponding connection pointer, i.e. of the
        connection pointer corresponding to the connection level of brc
        which is allocated in the nearest enclosing 'proper' block ;
      begin
         ref(quantity)q;

         q:-conpointqty(brc);
         conpointtag:=firstfortag(q)+q.descr.fornests+brc.connests-1;
      end conpointtag;



      ref(quantity) procedure conpointqty(brc);
      ref(brecord)brc;
      ! brc.kind=IINSP ;
      ! return representing quantity of the block which contains the
        connection pointer corresponding to brc ;
      begin
         ref(quantity) q;

         ! Go down on display the number of block levels corresponding
           to connection level of brc ;
         q:-display(brc.blev-brc.connests).declquant;

         ! Skip possible for-bodies:    ;
         while rank(q.kind)=IFORE do q:-q.prefqual;
         ! In case of procedure: connection pointer is allocated
           in procedure head ;
         if rank(q.kind)=IPROC then q:-q.prefqual;
         conpointqty:-q;
      end conpointqty;


      short integer procedure conlevel(q); ref(quantity)q;
      ! q.kind=ILABE and q.categ=IDCLI.
        Return connection level of the label;
      begin
         q:-q.encl.declquant;
         while rank(q.kind)=IFORE do q:-q.prefqual;
         conlevel:=if rank(q.kind)=IINSP then q.descr.connests else 0;
      end conlevel;


   !  ****  INSPECTSTART, RESETCONPOINT, WHENTEST   **** ;

          short integer INSPindex;

%+P       prior
          procedure inspectstart(INSPindex); short integer INSPindex;
          ! Called from LICONB and LIFWHN ;
          ! INSPindex contains the LO index ;
          ! TOS is reference to connected object;
          ! The stack is not altered ;
          begin
             ! none-test: ;
             outdup;
             outpushc(vonone);
             outfjumpif(IEQ,INSPindex);

             ! update connection pointer:  ;
             outpushv(Z_curins);
             outremote(tagstacktop);
             outrupdate;
          end inspectstart;

%+P       prior
          procedure resetconpoint;
          ! Called from LIWHEN, LICONE and LIOTHW ;
          ! Set the current connection pointer to none ;
          ! The stack is not altered ;
          begin
             outpushv(Z_curins);
             outremote(tagstacktop);
             outpushc(vonone);
             outassign;
          end resetconpoint;

%+P       prior
          procedure whentest(INSPindex); short integer INSPindex;
          ! Called from LIFWHN and LIWHEN ;
          ! opq is class quantity of a when-clause ;
          ! INSPindex is LNEXT index ;
          ! TOS is the object reference which is to be tested
            against opq;
          ! Net effect on the stack is to pop TOS;
          begin
             outremotev(Z_entity_pp);
             outdup;
             outremotev(Z_cpptp_plv);
             outpushcint(opq.plev);
             outif(IGT);
             outremote(Z_cpptp_pre);
             outpushcint(opq.plev);
             outindexv;
             outendif;
             outpushcaddr(vcoaddr,opq.ftag+prototypedisp);
             outfjumpif(INE,INSPindex);
          end whentest;

   end codegenerator1;


end SCODER1;
