External class PARSER;

PARSER class PAS1INIT;
%      -----------------------------------------------------------------------
%      ---                                                                 ---
%      ---  COPYRIGHT 1987 by                                              ---
%      ---  Simula a.s.                                                    ---
%      ---  Oslo, Norway                                                   ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---                 P O R T A B L E     S I M U L A                 ---
%      ---                                                                 ---
%      ---              F R O N T - E N D    C O M P I L E R               ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---        P a s s   1   -   i n i t i a l i s a t i o n            ---
%      ---                                                                 ---
%      ---  Selection switches: DKPI                                       ---
%      ---                                                                 ---
%      ---    'D' Included when dump is wanted                             ---
%      ---    'K' Included always when quick capability wanted             ---
%      ---    'P' Included to make compiler use quick procedures           ---
%      ---    'I' Included to make compiler use inserted mnemonics         ---
%      ---                                                                 ---
%      -----------------------------------------------------------------------
begin

%+I %INSERT (FEC-105)COMMON:MNE
%+I %INSERT (FEC-105)SCANNER:MNE
%+I %INSERT (FEC-105)PARSER:MNE

%   ******   Initialise COMMON   ******

      release:=   105;  !NOTE: ****** Should be Changed ******;

% -Z   maxconst:= getintinfo(37);
      if maxconst<=0  then maxconst:=1000;
      firstconst:=32766; !MAXID+MAXCONST;  lastconst:=firstconst+1;
      nextblno:=1;
      maxdepth:=100;     ! smallest acceptable value ;
      currentpass:='1';  ! in pass 1;
      lefttxtbuf:-blanks(35); !*** enough to hold long real ***;

% **************************************************************************
%INSERT (FEC-105)COMMON:INIT
% ***** must be followed immediately by the DEFIDENT-calls for various *****
% ***** identifiers. DO NOT CHANGE SEQUENCE BELOW (see STANDARDID:MNE) *****
% **************************************************************************

      DEFIDENT("*ERRID*");
%-I                             errorident      := hashindex;
      DEFIDENT("SIMSET");
%-I                             simsetindex     := hashindex;
      DEFIDENT("SIMULATION");
%-I                             simulationindex := hashindex;
      DEFIDENT("DETACH");
%-I                             detachident     := hashindex;
      DEFIDENT("_ACTIVATE1");
%-I                             actindex1       := hashindex;
      DEFIDENT("_ACTIVATE2");
%-I                             actindex2       := hashindex;
      DEFIDENT("_ACTIVATE3");
%-I                             actindex3       := hashindex;

%   ******  identifiers for standard procedures (inline-coded)  ******

      DEFIDENT("RANK");
%-I                             rankindex       := hashindex;
      DEFIDENT("ISORANK");
%-I                             isorankindex    := hashindex;
      DEFIDENT("CHAR");
%-I                             charindex       := hashindex;
      DEFIDENT("ISOCHAR");
%-I                             isocharindex    := hashindex;
      DEFIDENT("MAX");
%-I                             maxindex        := hashindex;
      DEFIDENT("MIN");
%-I                             minindex        := hashindex;
      DEFIDENT("SIGN");
%-I                             signindex       := hashindex;
      DEFIDENT("ABS");
%-I                             absindex        := hashindex;
      DEFIDENT("SOURCELINE");
%-I                             sourcelineindex := hashindex;
      DEFIDENT("REM");
%-I                             remindex        := hashindex;
      DEFIDENT("LOADCHAR");
%-I                             loadcharindex   := hashindex;    !non-standard;
      DEFIDENT("STORECHAR");
%-I                             storecharindex  := hashindex;   !non-standard;

% ***************   end of identifier list   *********************************

%-I   EOL:='!7!';          !*** BELL as character - see Pass1'terminator;

      DEFCONST("!63!"); questindex:=hashindex;

%title ******   Initialise PARSER   ******

      inspect new grammer do begin

            parser:- myparser:- this component;

%-I         allstmt:='!0!';     allbutif:='!1!';    outermost:='!2!';
%-I         classbody:='!3!';   stmtorinner:='!4!'; procbody:='!5!';
%-I         basicstmt:='!0!';   openstmt:='!1!';    innerstmt:='!2!';
%-I         declunit:='!3!';
%-I         compstmt:='!0!';    usualblock:='!1!';  prefixblock:='!2!';
%-I         declsymbol:='!1!';  exprtermin:='!2!';
%-I         arithop:='!3!';     relop:='!4!';       logop:='!5!';
%-I         stmtnotseen:='!1!'; lastwasstmt:='!2!'; lastwasdecl:='!3!';

            for cs:=IARRA,IBOOL,ICHAR,ICLAS,IEXTR,IINTG,ILONG,
                    IREAL,IREF,ISHOR,ISWIT,ITEXT,IPROC
             do symboltype(cs):=declsymbol;
            for cs:=IAFTR,IAT,IBEFO,IDELA,IDENO,IDO,IELSE,IOTHW,
                    IPRIO,ISTEP,ITHEN,IUNTI,IWHEN,ISMCL,IEOP,
                    IEND,IRGPA,ICOMA,ICL,IASSG
             do symboltype(cs):=exprtermin;
%              !*** this set should only be used in simple treatment
%                       of expression. "IBEGI" should not occur here
%                       as "P begin" should be sent as "IBPRE-P";
            for cs:=IPLUS,IMINU,IMULT,ISLAS,IPOWE,IIDIV,ICONC
             do symboltype(cs):=arithop;
            for cs:=IEQ,IGE,IGT,ILE,ILT,INE,IRFEQ,IRFNE
             do symboltype(cs):=relop;
            for cs:=IAND,IEQV,IIMP,IOR,ICAND,ICOR
             do symboltype(cs):=logop;
            setbasicrecovery;
            ex:-new expression; readfinish:=true;
            stmtstack:-new statementstack;

      end ***new grammer***;

      call(parser);   !*** i.e. NEXTSYMBOL;

%title ******   initialise RECOGNIZER   ******

      inspect new recognizer do begin

            scanner:-this component;
%-I         upcorr := isorank('a')-isorank('A'); !CONST ***;
            radix := 10;
            hashbuf :- blanks(80);

%     Note: the input classes below must satisfy the following conditions:
%           Illegal<Graphic<Skip<EOL<Format < all the other classes
%           Pseudo-classes Radix, IllDig, HexLow, HexUp  > all the other classes
%           Letter, Uscore, Digit > all classes except the four pseudo classes

%-I         Illegal_cl := '!01!'; Graphic_cl := '!02!'; Skip_cl    := '!03!';
%-I         EOL_cl     := '!04!'; Format_cl  := '!05!';
%-I         Exclam_cl  := '!06!'; Dquote_cl  := '!07!'; Ampsand_cl := '!08!';
%-I         Squote_cl  := '!09!'; Lpar_cl    := '!10!';
%-I         Rpar_cl    := '!11!'; Aster_cl   := '!12!'; Plus_cl    := '!13!';
%-I         Comma_cl   := '!14!'; Minus_cl   := '!15!';
%-I         Dot_cl     := '!16!'; Slash_cl   := '!17!'; Colon_cl   := '!18!';
%-I         Semic_cl   := '!19!'; Less_cl    := '!20!';
%-I         Equal_cl   := '!21!'; Greater_cl := '!22!'; Letter_cl  := '!23!';
%-I         Uscore_cl  := '!24!'; Digit_cl   := '!25!';
%-I         Radix_cl:='!26!';  IllDig_cl:='!27!'; HexLow_cl:='!28!';
%-I         HexUp_cl:='!29!';

            for i:=  1 step 1 until 255 do InputClass(i):=Graphic_cl;
            !*** most overwritten below - minimize code ***;

            InputClass(0):=InputClass(127):=Skip_cl;
            for i:=  1 step 1 until   7 do InputClass(i):=Illegal_cl;
            for i:=  8 step 1 until  13 do InputClass(i):=Format_cl;
            for i:= 14 step 1 until  31 do InputClass(i):=Illegal_cl;
            InputClass(32):= Format_cl; ! SPACE;
            InputClass(33):= Exclam_cl; ! exclamation point;
            InputClass(34):= Dquote_cl; ! double quote;
                                        ! 35-37 (number, dollar, percent);
            InputClass(38):=Ampsand_cl; ! ampersand;
            InputClass(39):= Squote_cl; ! single quote;
            InputClass(40):=   Lpar_cl; ! left  parenthesis;
            InputClass(41):=   Rpar_cl; ! right parenthesis;
            InputClass(42):=  Aster_cl; ! Asterix;
            InputClass(43):=   Plus_cl; ! Plus;
            InputClass(44):=  Comma_cl; ! Comma;
            InputClass(45):=  Minus_cl; ! Minus;
            InputClass(46):=    Dot_cl; ! Dot;
            InputClass(47):=  Slash_cl; ! Slash;
            for i:= 48 step 1 until  57 do InputClass(i):=Digit_cl;  ! digits;
            InputClass(58):=  Colon_cl; ! Colon;
            InputClass(59):=  Semic_cl; ! Semicolon;
            InputClass(60):=   Less_cl; ! Less than;
            InputClass(61):=  Equal_cl; ! Equals ;
            InputClass(62):=Greater_cl; ! Greater than;
                                        ! 63-64 (questionmark, ampersand);
            for i:= 65 step 1 until  90 do InputClass(i):=Letter_cl; ! letters;
                                        ! 91-94 (national);
            InputClass(95):= Uscore_cl; ! Underscore;
                                        ! 96 (national);
            for i:= 97 step 1 until 122 do InputClass(i):=Letter_cl; ! letters;

            InputClass(isorank(EOL)):=EOL_cl; ! End-of-line marker;

      end ***inspect new recognizer***;

%title ******   initialise L2CODER   ******

      inspect new L2CODER do begin

              coder:- this component;
              brecinit(IEXTR); !*** the brec at module level - no tags ***;

      end ***inspect new L2coder***;

end of PASSONE;
