External class SCODER2;

SCODER2 class SCODER3;
%      -----------------------------------------------------------------------
%      ---                                                                 ---
%      ---  COPYRIGHT 1985,86 by                                           ---
%      ---  Simula a.s.                                                    ---
%      ---  Oslo, Norway                                                   ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---                 P O R T A B L E     S I M U L A                 ---
%      ---                                                                 ---
%      ---              F R O N T - E N D    C O M P I L E R               ---
%      ---                                                                 ---
%      ---                                                                 ---
%      ---      S - C o d e    G e n e r a t o r     P a r t  3.           ---
%      ---                                                                 ---
%      --- Selection switches: PIZ                                         ---
%      ---                                                                 ---
%      ---    'D' Included when dump is wanted                             ---
%      ---    'K' Included always when quick capability wanted             ---
%      ---    'P' Included to make compiler use quick procedures           ---
%      ---    'I' Included to make compiler use inserted mnemonics         ---
%      ---    'Z' Included at system generation (for "ZIMULA")             ---
%      ---                                                                 ---
%      -----------------------------------------------------------------------
begin

%+I %INSERT (FEC-105)COMMON:MNE
%+I %INSERT (FEC-105)SCODER:MNE
%+I %INSERT (RTS-105)RTSINIT:MNE

codegenerator2 class codegenerator3;
begin

! ******************************************************************** ;
! This file mainly contains the parts of the coder considered with     ;
! transmission of parameters  to formal name or unspecified.           ;
! ******************************************************************** ;

        short integer txtrc;
        short integer ccc;
        ref(quantity) qqq;

%+P     prior
        procedure StopScode_3(n); short integer n;
        begin GiveMessage(linenr,2,cat(errcat(n,484),
                                       catTX(idname(curcall.dim),485)));
              termstatus:='6'; coder:-dumgen;
        end;

%title    ******************   procLIIDNlab   ******************
%+P     prior
        procedure procLIIDNlab;
%       ! In the general case, the reference to a label will result in
%         a LABQNT on TOS.  However, two cases are specially handled:
%         1) Goto single label, where label is local and is not a
%            parameter or a virtual.  Then E_GOTO is not required.
%         2) Single label as switch element, where the label is not
%            virtual or a name parameter.  Then thunk code is not
%            required.
%         The boolean notinconditional tells us whether or not the label
%         is part of a conditional expression.
%
        begin
              if ingotostmt and!then; notinconditional and!then;
                 opq.encl.blev=cblev and!then; opq.categ=char(IDCLI)
              then begin
                   outpushcaddr(vcpaddr,opq.ftag+quantdisp); outgoto; end
         else if inswitchdecl and!then; notinconditional and!then;
                 opq.categ<>char(IVIRT) and!then; opq.categ<>char(INAME)
              then begin
                  if opq.categ=char(IDCLI) then
                     swteltconst(false, opq.ftag+quantdisp,
                                 curcall.encl.rtblev-opq.encl.rtblev,0,
                                 ! curcall is the switch being declared ;
                                 conlevel(opq))
                  else ! categ=IFRMP ;
                     swteltconst(false,0,
                                 curcall.encl.rtblev-opq.encl.rtblev,
                                 opq.ftag+quantdisp,0);
              end
         else if curcall is extquantity then begin
                 if curcall qua extquantity.classific='E' then begin
                    if opq.categ <> char(IDCLI) then StopScode_3(483) else
                    if opq.encl.blev <> cblev then   StopScode_3(486)
                    else outpushcaddr(vcpaddr,opq.ftag+quantdisp);
                 end
                 else goto generallabel;
              end ***curcall-in-extquantity***
         else
  generallabel:
              if ingotostmt then begin
                 generalgoto:=true; get_LABQNT(opq); end
         else if inswitchdecl then notimp("switch element requiring thunk",0)
         else ! label in actual parameter expression:  ;
              get_LABQNT(opq);

        end procLIIDNlab;
%title   ******************   procLIIDNswt   ******************

%+P     prior
        procedure procLIIDNswt;

%        ! Switch identifier as start of switch designator
%          (switch identifier as actual parameter always
%          occurs as SINGLE-ACTUAL);
%        ! Goto plain, local switch designator is given special
%          treatment;

        begin
              if ingotostmt and!then; notinconditional and!then;
                 opq.plev=1 !plain; and!then; opq.encl.blev=cblev !local;
              then begin
                   outpush(opq.ftag+quantdisp);
                   outselect(Z_swtdes_elt);
                   pushcall(opq);
                   curstatus:='!1!';  ! Indicates optimised case ;
              end
              else begin
                   ! general switch designator ;
                   ! the index is to be first parameter to the routine
                     so nothing is done here ;
                   pushcall(opq);
              end;

        end procLIIDNswt;
%title   ******************   procLISSWA   ******************

        procedure procLISSWA;     ! (SINGLE-ACTUAL) ;
        begin
              if lastopc=IDCLS !SINGLE-STRONG; then begin
                 !  Single identifier as actual parameter to name or
                    unspecified formal parameter;

                 if curpar==none then begin
                    ! SCHEMES 9.4.2 Parameter transfer to formal or
                                    virtual procedure                ;

                    if opq.categ=char(INAME) then begin
                       outasscall(Z_b_fpt1);
                       addrPARQNT(opq,false);
                       outselectv(Z_parqnt_ent);
                       outasspar;
                       addrPARQNT(opq,false);
                       outselectv(Z_parqnt_ap);
                       outasspar;
                       outpushcint(curparno-1);
                       outasspar;
                       outcall(Z_b_fpt2,0);
                       outprecall(Z_e_fpt1);
                       outpushcint(curparno-1);
                       outasspar;
                       staticencl(opq);
                       outremotev(opq.ftag+quantdisp);
                       outasspar;
                       if opq.type=char(IREF) then staticencl(opq.prefqual)
                       else outpushc(vonone);
                       outasspar; outcall(Z_e_fpt2,1);

                    end
                    else inspect opq do begin
                       if categ=char(IVIRT) or!else;
                          (kind=char(IPROC) and!then; type<>char(INOTY)
                          and!then; (if kind=char(IPROC)
                                        and!then; categ=char(IVIRT)
                                        and!then; match=/=none
                                     then match.descr.npar=0
                                else if kind=char(IPROC) and!then;
                                  (categ=char(IDCLI) or!else; categ=char(IEXTR))
                                     then descr.npar=0 else false) )
                       then begin
                           ! virtual procedure,type proc,label or switch ,
                             thunk code to be generated           ;

                           beginthunk;

                           if kind=char(IPROC) then begin
                              get_PROQNT(opq,true !precall; );
                              if type <> char(INOTY) and!then; descr.npar=0
                              then begin
                                 outpushv(Z_curins);
                                 outremotev(Z_thunk_fis);
                                 outpushc(vtrue);
                                 outskipif(INE);
                                 outasscall(Z_b_fml_pro1);
                                 outcall(Z_b_fml_pro2,0);

                                 if (categ=char(IFRMP) or!else;
                                     categ=char(INAME)) and!then;
                                    (char(ISHOR)<=type and!then;
                                                  type<=char(ILONG))
                                 then begin
                                    outprecall(fnp_pro_1(rank(type)));
                                    addrPARQNT(opq,false);
                                    outselectv(Z_parqnt_ap);
                                    outremotev(Z_pardes_typ);
                                    outasspar;
                                    outcall(fnp_pro_2(rank(type)),1);
                                 end
                                 else begin
                                    outpush(Z_tmp);
                                    outselectv(Z_quant_pnt);
                                    outremotev(resulttag(rank(type)));
                                               !type_pro_tag;
                                 end;

                                 outpushv(Z_curins);
                                 outremote(Z_thunk_val);
                                 outselect(quantvarianttag(rank(type)));
                                 outrupdate;
                                 outpop;
                                 getnewindex; ll2:=curindex;
                                 outfjump(ll2);
                                 outendskip;
                              end;

                              ! the procedure shall be transmitted as such, is
                                on the stack;

                              outpushv(Z_curins);
                              outremote(Z_thunk_val);
                              outselect(Z_quant_pro);
                              outrupdate;
                              outpop;

                              if categ=char(IVIRT) or
                                 kind=char(IPROC) and type <> char(INOTY) and
                                 (if kind=char(IPROC) and
                                     categ=char(IVIRT) and match=/=none
                                  then match.descr.npar=0
                                  else if kind=char(IPROC) and
                                       (categ=char(IDCLI) or categ=char(IEXTR))
                                  then descr.npar=0
                                  else false)
                              then outfdest(ll2);
                           end

                           else begin
                              if kind=char(ILABE) then get_LABQNT(opq) else
                              if kind=char(ISWIT) then get_SWTQNT(opq);

                              outpushv(Z_curins);
                              outremote(Z_thunk_val);
                              outselect(if kind=char(ILABE) then Z_quant_lab
                                        else Z_quant_swt );
                              outrupdate;
                              outpop;
                           end;

                           endthunk;
                           thunklabel:=popjump;
                           constPARDES(par_thk_nas,
                                       rank(kind),rank(type),prefqual,
                                       thunklabel,0);

                           thunktounspecified(rank(type),prefqual);

                        end ***case-requiring-thunk***
                        else begin
                           constPARDES(if kind=char(IIDN) then PAR_QNT_ASS
                                       else PAR_QNT_NAS,
                                       ! par_qnt_lit will be issued at
                                                          SINGLE-CONST ;
                                       rank(kind),rank(type),prefqual,
                                       0,0);
                           outdup;
                           if kind=char(IIDN) then
                                       outasscall(fpt_profile(rank(type)))
                      else if kind=char(IARRA) then outasscall(Z_FPT_ARR1)
                      else if kind=char(IPROC) then outasscall(Z_FPT_PRO1)
                      else if kind=char(ILABE) then outasscall(Z_FPT_LAB1)
                      else if kind=char(ISWIT) then outasscall(Z_FPT_SWT1);

                           outpushcint(curparno-1);
                           outasspar;
                           outpushcaddr(vcoaddr,PDC);
                           outasspar;
                           if kind=char(IIDN) then begin
                              ! simple assignable attribute;
                              staticencl(opq);
                              outasspar;
                              outpushcaddr(vcaaddr,ftag+quantdisp);
                              outasspar;
                              if type=char(IREF) then begin
                                 staticencl(prefqual); outasspar end;
                           end
                           else begin
                              if kind=char(IPROC) then begin
                                 if type=char(IREF) then staticencl(prefqual)
                                 else outpushc(vonone);
                                 outasspar;
                                 get_PROQNT(opq,true !precall; );
                                 outasspar;
                              end
                         else if kind=char(IARRA) then begin
                                 if type=char(IREF) then staticencl(prefqual)
                                 else outpushc(vonone);
                                 outasspar;
                                 staticencl(opq);
                                 outremotev(ftag+quantdisp);
                                 outasspar;
                              end
                         else if kind=char(ILABE) then begin
                                 get_LABQNT(opq); outasspar end
                         else if kind=char(ISWIT) then begin
                                 get_SWTQNT(opq);
                                 get_SWTQNT(opq); outasspar end
                              else ! ??? ;
                           end;

                           if kind=char(IIDN) then
                                          outcall(fpt_body(rank(type)),0)
                      else if kind=char(IARRA) then outcall(Z_FPT_ARR2,0)
                      else if kind=char(IPROC) then outcall(Z_FPT_PRO2,0)
                      else if kind=char(ILABE) then outcall(Z_FPT_LAB2,0)
                      else if kind=char(ISWIT) then outcall(Z_FPT_SWT2,0);

                        end no thunk;
                     end inspect of opq;

                  end curpar==none
                  else begin
                       ! single actual to formal name, opq denotes actual
                         curpar denotes formal parameter ;
                       ! SCHEMES 9.4.1 Transfer to formal name parameter ;

                     if (if curcall is extquantity then
                            curcall qua extquantity.classific <> 'N'
                         else false)
                     then ! By address (i.e. by name to non-Simula procedure) ;
                          GADDRval
                     else inspect opq do begin
                        if categ=char(INAME) then begin
                           outdup;
                           outremote(curpar.ftag+quantdisp);
                           staticencl(opq);
                           outremote(ftag+quantdisp);
                           outassign;
                           update_PARQNT;
                           select_PARQNT(Z_parqnt_sem);
                           outdup;
                           if kind=char(IIDN) and!then; curpar.kind=char(IIDN)
                              and!then; type=curpar.type and!then;
                              (if type=char(IREF)
                               then prefqual==curpar.prefqual else true)
                           then outpushc(vtrue) else outpushc(vfalse);
                           outbinary(IAND);
                           outassign;
                        end
                   else if categ=char(IVIRT) then begin
                           ! virtual procedure or label or switch,
                             thunk has to be generated             ;

                           beginthunk;   ! allocates thunklabel tag ;

                           if kind=char(IPROC) then get_PROQNT(opq,true)
                      else if kind=char(ILABE) then get_LABQNT(opq)
                      else if kind=char(ISWIT) then get_SWTQNT(opq);

                           outpushv(Z_curins);
                           outremote(Z_thunk_val);
                           outselect(     if kind=char(IPROC) then Z_quant_pro
                                     else if kind=char(ILABE) then Z_quant_lab
                                          else Z_quant_swt        );
                           outrupdate;
                           outpop;

                           endthunk;
                           thunklabel:=popjump;
                           constPARDES(par_thk_nas,
                                       rank(kind),rank(type),prefqual,
                                       thunklabel,0);

                           update_PARQNT;
                           select_PARQNT(Z_parqnt_ap);
                           outpushcaddr(vcoaddr,PDC);
                           outassign;

                           select_PARQNT(Z_parqnt_ent);
                           outpushv(Z_curins);
                           outassign;
                        end

                        else begin

                           constPARDES(if kind=char(IIDN) then par_qnt_ass
                                       else par_qnt_nas,
                                            ! par_qnt_lit will be issued
                                              at SINGLE-CONST ;
                                       rank(kind),rank(type),prefqual,
                                       0,0);

                           update_PARQNT;
                           select_PARQNT(Z_parqnt_ap);
                           outpushcaddr(vcoaddr,PDC);
                           outassign;

                           if kind=char(IIDN) then begin
                              select_PARQNT(Z_parqnt_ent);
                              staticencl(opq);
                              outassign;

                              if curpar.kind=char(IIDN) and!then;
                                 curpar.type=type and!then;
                                 (if type=char(IREF)
                                  then prefqual==curpar.prefqual else true)
                              then begin
                                 select_PARQNT(Z_parqnt_sem);
                                 outpushc(vtrue);
                                 outassign;
                              end;
                              select_PARQNT(Z_parqnt_fld);
                              outpushcaddr(vcaaddr,ftag+quantdisp);
                              outassign;

                           end

                      else if kind=char(IARRA) then begin
                              select_PARQNT(Z_parqnt_ent);
                              staticencl(opq);
                              outremote(ftag+quantdisp);
                              outassign;
                           end

                      else if kind=char(IPROC) then begin
                              if categ=char(IFRMP) then begin
                                 select_PARQNT(Z_parqnt_ent);
                                 staticencl(opq);
                                 outremote(ftag+quantdisp);
                                 outselectv(Z_proqnt_sl);
                                 outassign;

                                 select_PARQNT(Z_parqnt_ppp);
                                 staticencl(opq);
                                 outremote(ftag+quantdisp);
                                 outselectv(Z_proqnt_ppp);
                                 outassign;

                                 select_PARQNT(Z_parqnt_qal);
                                 staticencl(opq);
                                 outremote(ftag+quantdisp);
                                 outselectv(Z_proqnt_qal);
                                 outassign;
                              end
                              else begin
                                 select_PARQNT(Z_parqnt_ent);
                                 staticencl(opq);
                                 outassign;

                                 select_PARQNT(Z_parqnt_ppp);
                                 outpushcaddr(vcoaddr,ftag+prototypedisp);
                                 outassign;

                                 if type=char(IREF) then begin
                                    select_PARQNT(Z_parqnt_qal);
                                    outpushcaddr(vcoaddr,
                                                 prefqual.ftag+prototypedisp);
                                    outassign;
                                 end;
                              end;
                           end

                      else if kind=char(ILABE) then begin
                              if categ=char(IFRMP) then begin
                                 select_PARQNT(Z_parqnt_ent);
                                 staticencl(opq);
                                 outremote(ftag);
                                 outselect(Z_labqnt_sl);
                                 outassign;

                                 select_PARQNT(Z_parqnt_pad);
                                 staticencl(opq);
                                 outremote(ftag);
                                 outselect(Z_labqnt_pad);
                                 outassign;

                                 select_PARQNT(Z_parqnt_clv);
                                 staticencl(opq);
                                 outremote(ftag);
                                 outselect(Z_labqnt_clv);
                                 outassign;
                              end
                              else begin
                                 select_PARQNT(Z_parqnt_ent);
                                 staticencl(opq);
                                 outassign;

                                 select_PARQNT(Z_parqnt_pad);
                                 outpushcaddr(vcpaddr,ftag+quantdisp);
                                 outassign;

                                 select_PARQNT(Z_parqnt_clv);
                                 outpushcint(conlevel(opq));
                                 outassign;
                              end;
                           end

                      else if kind=char(ISWIT) then begin

                           end;
                        end;

                     end inspect of opq;
                  end;

               end

%          procedure,array or switch as such as actual parameter
%          to formal not name parameter of same kind:

          else if opq.kind=char(IPROC) then get_PROQNT(opq,true !precall; )
          else if opq.kind=char(IARRA) then get_ARRPNT(opq)
          else if opq.kind=char(ISWIT) then get_SWTQNT(opq)
               else StopScode_2(592,opq.line); !illegal actual parameter;

        end procLISSWA;
%title   ******************   procLILFPA   ******************

      procedure procLILFPA;       ! (DOT-ACTUAL) ;
      begin
            if lastopc <> IQUA then outnonetest(vonone,IDOT);
            if (if curpar==none then true else curpar.categ=char(INAME))
            then begin
                 ! remote actual to formal name or unspecified,
                   actual expression is started by EXP-STRONG;
                 ! opq.kind=IPROC,IIDN or IARRA ;

               inspect opq do begin

                  if (if curpar is extquantity then
                      curpar qua extquantity.classific <> 'N' else false)
                  then begin
                       ! By address (i.e. by name to non-Simula procedure) ;
                     outremote(ftag+quantdisp);
                     outderef;
                  end
                  else begin
                       ! Thunk has been started, here follows
                         last part of the thunk code ;

                     if kind=char(IIDN) then begin
                        ! remote assignable expression ;

                        outpushv(Z_curins);
                        outremote(Z_thunk_val);
                        outselect(Z_quant_ins);
                        outrupdate;
                        outpop;

                        outpushv(Z_curins);
                        outremote(Z_thunk_val);
                        outselect(Z_quant_fld);
                        outpushcaddr(vcaaddr,ftag+quantdisp);
                        outassign;
                     end

                else if kind=char(IARRA) then begin
                        ! remote array ;

                        outremote(ftag+quantdisp);

                        outpushv(Z_curins);
                        outremote(Z_thunk_val);

                        outselect(Z_quant_arr);
                        outrupdate;
                        outpop;

                     end

                else if kind=char(IPROC) then begin
                        ! remote procedure  r.p                              ;
                        ! r is on the stack                                  ;
                        ! it shall be tested if the procedure is to be called;
                        ! or transferred as such                             ;

                        get_PROQNT(opq,false !asscall; );

                        if type <> char(INOTY) and!then;
                           (if categ=char(IVIRT) and!then; match=/=none
                            then match.descr.npar=0 else descr.npar=0)
                        then begin
                           outpushv(Z_curins);
                           outremotev(Z_thunk_fis);
                           outpushc(vtrue);
                           outskipif(INE);
                           outasscall(Z_b_fml_pro1);
                           outcall(Z_b_fml_pro2,0);

                           if (categ=char(IFRMP) or!else; categ=char(INAME))
                              and!then; (char(ISHOR)<=type and!then;
                                                      type<=char(ILONG))
                           then begin
                              outprecall(fnp_pro_1(rank(type)));
                              addrPARQNT(opq,false);
                              outselectv(Z_parqnt_ap);
                              outremotev(Z_pardes_typ);
                              outasspar;
                              outcall(fnp_pro_2(rank(type)),1);
                           end
                           else begin
                              outpush(Z_tmp);
                              outselectv(Z_quant_pnt);
                              outremotev(!type_pro_tag;resulttag(rank(type)));
                           end;

                           outpushv(Z_curins);
                           outremote(Z_thunk_val);
                           outselect(quantvarianttag(rank(type)));
                           outrupdate;
                           outpop;
                           getnewindex; ll2:=curindex;
                           outfjump(ll2);
                           outendskip;
                        end;

                        ! the procedure shall be transmitted as such, is
                          on the stack;

                        outpushv(Z_curins);
                        outremote(Z_thunk_val);
                        outselect(Z_quant_pro);
                        outrupdate;
                        outpop;

                        if type <> char(INOTY) and!then;
                           (if categ=char(IVIRT) and!then; match=/=none
                            then match.descr.npar=0 else descr.npar=0)
                        then outfdest(ll2);

                     end;

                     endthunk;
                     thunklabel:=popjump;
                     constPARDES(if kind=char(IIDN) then par_thk_ass
                                 else par_thk_nas ,
                                 rank(kind),rank(type),prefqual,
                                 thunklabel,0);

                     if curpar=/=none then begin
                        ! remote actual to formal name ;

                        update_PARQNT;
                        select_PARQNT(Z_parqnt_ap);
                        outpushcaddr(vcoaddr,PDC);
                        outassign;

                        select_PARQNT(Z_parqnt_ent);
                        outpushv(Z_curins);
                        outassign;
                     end
                     else begin
                          !actual parameter to formal unspecified;

                        thunktounspecified(rank(type),prefqual);
                     end;
                  end;

               end inspect opq ;

            end

%           remote actual to formal specified not name and of the
%           same kind as the actual

          else if curpar.kind=char(IPROC) then get_PROQNT(opq,false !asscall;)
          else if curpar.kind=char(IARRA) then outremotev(opq.ftag+quantdisp)
               else StopScode_1(588); ! DOT-ACTUAL: illegal kind ;

      end procLILFPA;
%title   ******************   procLIARRA   ******************

      procedure procLIARRA;             ! (SUBSCRIPT-ACTUAL) ;
      begin short integer ccc;
            ! Has been started with EXP-STRONG;

%           if (if curcall.prev.caller is extquantity
%               then curcall.prev.caller qua extquantity.classific<>'N'
%               else false)
            if (if callstack(calldepth-1) is extquantity then
                   callstack(calldepth-1)
                   qua extquantity.classific <> 'N' else false)
            then begin
                 ! By address (i.e. by name to non-Simula procedure) ;
                endsubscription(IREF); outderef;
                popcall;  ! for the subscription;  end

            else begin ! A thunk has been started;
                if curcall.kind=char(ISWIT) then begin
                   ! switch designator termination. The code for the switch
                     access and the index expression has been generated  ;

                   !    outasspar;   ! transmits the index expression ;
                   !    outcall(Z_sw_t_lab2,0);
                   !    expandrestore;
                   !    outpush(Z_tmp);
                   !    outselectv(Z_quant_lab);
                   !    ! label quantity on the stack;
                   !    outpushv(Z_curins);
                   !    outremote(Z_thunk_val);
                   !    outselect(Z_quant_lab);
                   !    outrupdate;
                   !    outpop;
                end
                else  begin !array access;
                        endsubscription(IREF); outderef;
                        outdup; outconvert(IREF);
                        outpushv(Z_curins); outremote(Z_thunk_val);
                        outselect(Z_quant_ins); outrupdate; outpop;
                        outconvert(IVALU);   ! should give ptaaddr  ;
                        outpushv(Z_curins); outremote(Z_thunk_val);
                        outselect(Z_quant_fld); outrupdate; outpop;
                end;
                endthunk; thunklabel:=popjump;
                qqq:-curcall.prefqual; ccc:=rank(curcall.type);
                popcall;  ! for the subscription;
                constPARDES(par_thk_ass,IIDN,ccc,qqq,thunklabel,0);
                if curpar==none then begin
                        !actual subscript to formal unspecified;
                   thunktounspecified(ccc,qqq);
                end
                else  begin !actual subscript to formal name ;
                   update_PARQNT;
                   select_PARQNT(Z_parqnt_ap);
                   outpushcaddr(vcoaddr,PDC); outassign;
                   select_PARQNT(Z_parqnt_ent);
                   outpushv(Z_curins); outassign;
               end;
            end;
      end procLIARRA;
%title   ******************   procLIPOWE   ******************

%+P   prior
      procedure procLIPOWE;
            ! Binary exponentiation. First operand type in optx,  ;
            ! second operand type in opt.  Infix if opi=1  ;
      if opi=1 then begin ! infix power ;
            if opt<IREAL then outasscall(
                  if optx<IREAL then Z_iipower1 else
                  if optx=IREAL then Z_ripower1 else Z_dipower1)
            else begin
               if optx<IREAL then outconvert(opt);
               outasscall(if opt=IREAL then
                          (if optx<=IREAL then Z_rrpower1 else Z_drpower1)
                      else if optx =IREAL then Z_rdpower1 else Z_ddpower1 );
            end

      end ***infix***

      else begin ! postfix power;

            outasspar;
            outcall(     if opt<IREAL then
                             (if optx<IREAL then Z_iipower2 else
                              if optx=IREAL then Z_ripower2 else Z_dipower2)
                    else if opt=IREAL then
                             (if optx<=IREAL then Z_rrpower2 else Z_drpower2)
                    else if optx =IREAL then Z_rdpower2 else Z_ddpower2,1);

      end ***postfix*** and procLIPOWE;
%title   ******************   procLIDCLS/LIDCLI   ******************

%+P   prior
      procedure procLIDCLS; ! SINGLE-STRONG ;
      begin
            curparno:=curparno + 1;
            if opq=/=none then begin
               ! start of single actual to formal name parameter ;
               if curpar=/=none then termpar;
               curpar:-opq; ! startpar(curpar);
            end ;
      end procLIDCLS;




! ******************   procLIDCLI   ****************** ;

%+P   prior
      procedure procLIDCLI; ! EXP-STRONG ;
      begin curparno:=curparno + 1;
            if opq==none then beginthunk else
            begin if curpar=/=none then termpar;
                  curpar:-opq; !  startpar(curpar);
                  if (if curpar is extquantity then
                      curpar qua extquantity.classific='N' else true)
                  then beginthunk;
            end;
      end procLIDCLI;
%title   ******************   procLIUPLS   ******************

      procedure procLIUPLS; ! UCH-PARAM-END ;
      begin
            ! curcall is a formal/virtual procedure. If there has actually
              been no parameters, code to call B_FML/VIR_PRO has been
              completed (at PARAM-BEGIN). If there has been parameters,
              the transmission is ended and I_PRO should be called ;

            if opi <> 0 then begin
               ! one or more actual parameters have been transmitted;
               outasscall(Z_i_pro1);
               outcall(Z_i_pro2,0);
            end;
            expandrestore;

            inspect curcall do begin
               if type <> char(INOTY) then begin
                  if categ=char(INAME) then begin

                     if char(ISHOR)<=type and!then; type<=char(ILONG)
                     then begin
                        outprecall(fnp_pro_1(rank(type)));
                        addrPARQNT(curcall,false);
                        outselectv(Z_parqnt_ap);
                        outremotev(Z_pardes_typ);
                        outasspar;
                        outcall(fnp_pro_2(rank(type)),1);
                     end
                     else begin
                        outpush(Z_tmp);
                        outselectv(Z_quant_pnt);
                        outremotev(resulttag(rank(type)));
                        outeval;
                     end;
                  end

                  else begin
                     outpush(Z_tmp);
                     outselectv(Z_quant_pnt);
                     outremotev(resulttag(rank(type)));
                     outeval;
                  end;
               end type <> INOTY;
            end inspect of curcall;

            popcall;

      end procLIUPLS;
%title   ******************   procLIRGPA   ******************

%+P   prior
      procedure procLIRGPA; ! (EXP-ACTUAL) ;
      begin ! trailing part of thunk code:    ;
            outpushv(Z_curins);
            outremote(Z_thunk_val);
            if opt=ILABE then begin
                 ! assumes that label quantity on the stack;
               outselect(Z_quant_lab);
               outrupdate;
               outpop;
            end
            else begin
                 ! non-assignable expression of simple kind. All other
                   kinds of expressions are terminated by DOT-ACTUAL or
                   SUBSCRIPT-ACTUAL   ;
               outselect(quantvarianttag(opt));
               outrupdate;
               outpop;
            end;
            endthunk;
            thunklabel:=popjump;
            constPARDES(par_thk_nas,IIDN !kind simple;, opt, opq,
                        thunklabel,0);

            if curpar==none then  ! expression to formal unspecified ;
               thunktounspecified(opt,opq)
            else begin            ! expression to formal name ;
               update_PARQNT;
               select_PARQNT(Z_parqnt_ap);
               outpushcaddr(vcoaddr,PDC);
               outassign;

               select_PARQNT(Z_parqnt_ent);
               outpushv(Z_curins);
               outassign;
            end;

      end procLIRGPA;
%title   *************   array access   ***************

! ******************   fnp_acc_smp ****************** ;
%+P   prior
      procedure fnp_acc_smp;
      ! Called from LIIDN:/LISIDN:  ;
      ! opq.categ=INAME ;
      ! Access of simple name parameter in opq ;
      begin
            addrPARQNT(opq,false);
            outselect(Z_parqnt_sem);
            outpushc(vtrue);
            outif(IEQ);
            addrPARQNT(opq,false);
            outselect(Z_parqnt_ent);
            addrPARQNT(opq,false);
            outselect(Z_parqnt_fld);
            outlocate;
            outrefer(typetag(rank(opq.type)));  ! this is formal type ;
            outfetch;
            outelse;

            expandsave;
            outprecall(Z_b_fnp_acc1);
            addrPARQNT(opq,true);
            outasspar;
            outcall(Z_b_fnp_acc2,0);
            expandrestore;

            outprecall(e_fnp_acc1(rank(opq.type)));
            addrPARQNT(opq,true);
            outasspar;
            outcall(e_fnp_acc2(rank(opq.type)),1);

            outendif;

      end fnp_acc_smp;



! ******************   fnp_acc_arr ****************** ;
%+P   prior
      procedure fnp_acc_arr;
      ! Called from LIIDN:/LISIDN:  ;
      ! opq.categ=INAME ;
      ! Access of array name parameter in opq ;
      begin
            expandsave;
            outprecall(Z_b_fnp_acc1);
            addrPARQNT(opq,true);
            outasspar;
            outcall(Z_b_fnp_acc2,0);
            expandrestore;

            outprecall(Z_e_acc_arr1);
            addrPARQNT(opq,true);
            outasspar;
            outcall(Z_e_acc_arr2,1);

      end fnp_acc_arr;

%     procedures below replaced by arrays in SCODER0

%     short integer procedure e_fnp_acc1(type); short integer type;
%     begin ! Gives the profile tag of the routine E_FNP_ACC_<type> ;
%           if type=IBOOL then e_fnp_acc1:=Z_e_acc_boo1  else
%           if type=ICHAR then e_fnp_acc1:=Z_e_acc_cha1  else
%           if type=IINTG then e_fnp_acc1:=Z_e_acc_int1  else
%           if type=ISHOR then e_fnp_acc1:=Z_e_acc_sin1  else
%           if type=IREAL then e_fnp_acc1:=Z_e_acc_rea1  else
%           if type=ILONG then e_fnp_acc1:=Z_e_acc_lrl1  else
%           if type=IREF  then e_fnp_acc1:=Z_e_acc_ref1  else
%           if type=ITEXT then e_fnp_acc1:=Z_e_acc_txt1  else
%              StopScode_1(694); !e_fnp_acc1;
%     end e_fnp_acc1;

%     short integer procedure e_fnp_acc2(type); short integer type;
%     begin ! Gives the body tag of the routine E_FNP_ACC_<type> ;
%           if type=IBOOL then e_fnp_acc2:=Z_e_acc_boo2  else
%           if type=ICHAR then e_fnp_acc2:=Z_e_acc_cha2  else
%           if type=IINTG then e_fnp_acc2:=Z_e_acc_int2  else
%           if type=ISHOR then e_fnp_acc2:=Z_e_acc_sin2  else
%           if type=IREAL then e_fnp_acc2:=Z_e_acc_rea2  else
%           if type=ILONG then e_fnp_acc2:=Z_e_acc_lrl2  else
%           if type=IREF  then e_fnp_acc2:=Z_e_acc_ref2  else
%           if type=ITEXT then e_fnp_acc2:=Z_e_acc_txt2  else
%              StopScode_1(695); !e_fnp_acc2;
%     end e_fnp_acc2;
%title
short integer thunklev;   !--- VI TROR AT DETTE ER LURT ----;


%+P   prior
      procedure beginthunk;
      begin thunklabel:= lastusedtag:= lastusedtag + 1;
            pushjump(thunklabel);
            outbseg;
            outlabeldef(thunklabel);
            if thunklev=0 then       !NY KODE;
            crtblev:=crtblev+1;
            thunklev:=thunklev+1;    !NY KODE;
      end;

%+P   prior
      procedure endthunk;
      begin outprecall(Z_e_thk1);
            outcall(Z_e_thk2,0);
            outeseg;
            thunklev:=thunklev-1;    !NY KODE;
            if thunklev=0 then       !NY KODE;
            crtblev:=crtblev-1;
      end;


      short integer PDC;

%+P   prior
      procedure constPARDES(code,kind,type,q,pad,constant);
      short integer kind,type; ref(quantity)q; !qualification;
      short integer code;     ! PAR_ ...           ;
      short integer pad;      ! tag of thunk label ;
      short integer constant; ! index of constant  ;
      begin
         PDC:= lastusedtag:= lastusedtag + 1;

         if code=par_qnt_lit then
         begin
!           outconstdef(PDC,Z_LPARDES);
!           outrecordconst( Z_LPARDES);
!           outattrconst(Z_pardes_cod,ptint);
!           outinteger(code);
!           outattrconst(Z_pardes_kin,ptint);
!           outinteger(rtskind(kind));
!           outattrconst(Z_pardes_typ,ptint);
!           outinteger(rtstypecode(type));

         end par_qnt_lit  else
         if code=par_qnt_nas or!else; code=par_qnt_ass then
         begin
            outconstdef(PDC,if type=IREF then Z_rpardes else Z_pardes);
            outrecordconst(if type=IREF then Z_rpardes
                                        else Z_pardes   );
            outattrconst(Z_pardes_cod,ptint);
            outinteger(code);
            outattrconst(Z_pardes_kin,ptint);
            outinteger(rtskind(kind));
            outattrconst(Z_pardes_typ,ptint);
            outinteger(rtstypecode(type));
            if type=IREF then
            begin
               outattrconst(Z_rpardes_qa,ptoaddr);
               outaddrconst(vcoaddr,q.ftag+prototypedisp);
            end;

         end par_qnt_nas or par_qnt_ass  else

         if code=par_thk_nas  or!else; code=par_thk_ass then
         begin
            outconstdef(PDC,if type=IREF then Z_rtpardes else Z_tpardes);
            outrecordconst(if type=IREF then Z_rtpardes
                                        else Z_tpardes   );
            outattrconst(Z_pardes_cod,ptint);
            outinteger(code);
            outattrconst(Z_pardes_kin,ptint);
            outinteger(rtskind(kind));
            outattrconst(Z_pardes_typ,ptint);
            outinteger(rtstypecode(type));
            if type=IREF then
            begin
               outattrconst(Z_rpardes_qa,ptoaddr);
               outaddrconst(vcoaddr,q.ftag+prototypedisp);
            end;
            outattrconst(if type=IREF then Z_rtpardes_pa
                                      else Z_tpardes_pa,
                         ptpaddr);
            outaddrconst(vcpaddr,pad);

         end par_thk_nas or par_thk_ass  else  ;
         outendrecord;
      end;


%+P   prior
      procedure update_PARQNT;
      begin
         ! generates the first common part of update_PARQNT ;

         select_PARQNT(Z_parqnt_fp);
         outpushcaddr(vcoaddr,curpar.ftag+atrdesdisp);
         outassign;
      end;

%+P   prior
      procedure select_PARQNT(att); short integer att;
      begin
         outdup;
         outremote(curpar.ftag+quantdisp);
         outselect(att)
      end;


%+P   prior
      procedure thunktounspecified(type,q);
      short integer type; ref(quantity)q;
      begin ! type is the type of the expression which the thunk ends
              up with, in case of IREF q denotes the qualifying class   ;
         ! generates code to call FPT with a thunk PARQNT ;

         ! OADDR of parameter instance on top of stack;

         outasscall(Z_b_fpt1);
         outpushv(Z_curins);
         outasspar;
         outpushcaddr(vcoaddr,PDC);
         outasspar;
         outpushcint(curparno-1);
         outasspar;
         outcall(Z_b_fpt2,0);

         outprecall(Z_e_fpt1);
         outpushcint(curparno-1);
         outasspar;
         outprecall(Z_make_t_pq1);
         outpushcaddr(vcoaddr,PDC);
         outasspar;
         outcall(Z_make_t_pq2,1);

         outasspar;
         if type=IREF then staticencl(q) else outpushc(vonone);
         outasspar;
         outcall(Z_e_fpt2,1);
      end;

%     The following procedures have been replaced by arrays (SCODER0)
%
%     short integer procedure litpardesvarianttag(v); short integer v;
%     begin if v=IINTG then litpardesvarianttag:= Z_lpardes_in   else
%           if v=IREAL then litpardesvarianttag:= Z_lpardes_re  else
%           if v=IBOOL then litpardesvarianttag:= Z_lpardes_bo  else
%           if v=ICHAR then litpardesvarianttag:= Z_lpardes_ch  else
%           if v=ITEXT then litpardesvarianttag:= Z_lpardes_tx  else
%           if v=IREF  then litpardesvarianttag:= Z_lpardes_rf  else
%           if v=ISHOR then litpardesvarianttag:= Z_lpardes_si  else
%           if v=ILONG then litpardesvarianttag:= Z_lpardes_lr else
%           StopScode_1(577); !unexpected variant in quantvarianttag;
%     end;

%     short integer procedure fpt_profile(type); short integer type;
%     begin if type=IBOOL then fpt_profile:= Z_FPT_BOO1 else
%           if type=ICHAR then fpt_profile:= Z_FPT_CHA1 else
%           if type=ISHOR then fpt_profile:= Z_FPT_SIN1 else
%           if type=IINTG then fpt_profile:= Z_FPT_INT1 else
%           if type=IREAL then fpt_profile:= Z_FPT_REA1 else
%           if type=ILONG then fpt_profile:= Z_FPT_LRL1 else
%           if type=IREF  then fpt_profile:= Z_FPT_REF1 else
%           if type=ITEXT then fpt_profile:= Z_FPT_TXT1 else
%              StopScode_1(682)
%     end;
%
%     short integer procedure fpt_body(type); short integer type;
%     begin if type=IBOOL then fpt_body:= Z_FPT_BOO2 else
%           if type=ICHAR then fpt_body:= Z_FPT_CHA2 else
%           if type=ISHOR then fpt_body:= Z_FPT_SIN2 else
%           if type=IINTG then fpt_body:= Z_FPT_INT2 else
%           if type=IREAL then fpt_body:= Z_FPT_REA2 else
%           if type=ILONG then fpt_body:= Z_FPT_LRL2 else
%           if type=IREF  then fpt_body:= Z_FPT_REF2 else
%           if type=ITEXT then fpt_body:= Z_FPT_TXT2 else
%              StopScode_1(683);
%     end;

end codegenerator3;
end SCODER3;
